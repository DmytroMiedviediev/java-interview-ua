[Питання на співбесіду](README.md)

# ООП
# Базові питання з ООП
+ [Що таке _об’єктно-орієнтоване програмування (ООП)_?](#що-таке-обєктно-орієнтоване-програмування-ооп)
+ [Які основні принципи _ООП_?](#які-основні-принципи-ооп)
+ [Що таке _інкапсуляція_?](#що-таке-інкапсуляція)
+ [Що таке _наслідування_?](#що-таке-наслідування)
+ [Що таке _поліморфізм_?](#що-таке-поліморфізм)
+ [Що таке _абстракція_?](#що-таке-абстракція)
+ [Що таке _обмін повідомленнями_ в ООП?](#що-таке-обмін-повідомленнями-в-ооп)
+ [У чому різниця між _класом_ і _об’єктом_?](#у-чому-різниця-між-класом-і-обєктом)
+ [Що таке _інтерфейс_ і як він використовується в ООП?](#що-таке-інтерфейс-і-як-він-використовується-в-ооп)
+ [Що означає _реалізує інтерфейс_ (implements interface)?](#що-означає-реалізує-інтерфейс-implements-interface)
+ [Що означає _успадковує клас_ (extends class)?](#що-означає-успадковує-клас-extends-class)
+ [Що таке _конструктор_? Які бувають типи конструкторів?](#що-таке-конструктор-які-бувають-типи-конструкторів)

# Проміжні питання з ООП
+ [У чому полягають _переваги та недоліки ООП_?](#у-чому-полягають-переваги-та-недоліки-ооп)
+ [Яка роль _модифікаторів доступу_ (private, protected, public) у реалізації інкапсуляції?](#яка-роль-модифікаторів-доступу-private-protected-public-у-реалізації-інкапсуляції)
+ [У чому різниця між _перевантаженням_ (overloading) та _перевизначенням_ (overriding) методів?](#у-чому-різниця-між-перевантаженням-overloading-та-перевизначенням-overriding-методів)
+ [Що таке _dynamic dispatch_ (динамічна диспетчеризація)?](#що-таке-dynamic-dispatch-динамічна-диспетчеризація)
+ [У чому різниця між _абстрактним класом_ та _інтерфейсом_?](#у-чому-різниця-між-абстрактним-класом-та-інтерфейсом)
+ [Чим відрізняється _компіляторне (статичне)_ та _виконуване (динамічне) зв’язування_?](#чим-відрізняється-компіляторне-статичне-та-виконуване-динамічне-звязування)
+ [Що таке _final метод / клас / змінна_ і як це пов’язано з ООП?](#що-таке-final-метод--клас--змінна-і-як-це-повязано-з-ооп)
+ [Яка роль ключового слова _super_?](#яка-роль-ключового-слова-super)
+ [Як працює механізм _пізнього (динамічного) зв'язування_ в Java?](#як-працює-механізм-пізнього-динамічного-звязування-в-java)
+ [Що таке _instanceof_ і як воно пов'язане з поліморфізмом?](#що-таке-instanceof-і-як-воно-повязане-з-поліморфізмом)
+ [Чим відрізняється _shallow copy_ від _deep copy_?](#чим-відрізняється-shallow-copy-від-deep-copy)

# Поглиблені питання з ООП
+ [Що означають принципи _«IS-A» (є)_ та _«HAS-A» (має)_?](#що-означають-принципи-is-a-є-та-has-a-має)
+ [У чому різниця між _композицією_ та _агрегацією_?](#у-чому-різниця-між-композицією-та-агрегацією)
+ [Чому _композиція_ вважається кращою за _успадкування_?](#чому-композиція-вважається-кращою-за-успадкування)
+ [Що таке _«Liskov Substitution Principle»_ (Принцип підстановки Лісков)?](#що-таке-liskov-substitution-principle-принцип-підстановки-лісков)
+ [Як реалізується _інтерфейсний поліморфізм_ у Java?](#як-реалізується-інтерфейсний-поліморфізм-у-java)
+ [Що таке _шаблонний метод_ (template method pattern) і як він пов’язаний з ООП?](#що-таке-шаблонний-метод-template-method-pattern-і-як-він-повязаний-з-ооп)
+ [Як реалізується _інкапсуляція на рівні модуля або пакету_?](#як-реалізується-інкапсуляція-на-рівні-модуля-або-пакету)
+ [Як працює механізм _віртуальних методів_ (virtual methods)?](#як-працює-механізм-віртуальних-методів-virtual-methods)
+ [Які _типові помилки_ при використанні ООП?](#які-типові-помилки-при-використанні-ооп)
+ [Що таке _множинне наслідування_? Чому Java його не підтримує для класів?](#що-таке-множинне-успадкування-чому-java-його-не-підтримує-для-класів)
+ [Як Java дозволяє реалізувати _подібність до множинного наслідування_?](#як-java-дозволяє-реалізувати-подібність-до-множинного-успадкування)

# Прикладні питання та сценарії
+ [У яких випадках краще використовувати _абстрактний клас_, а в яких — _інтерфейс_?](#у-яких-випадках-краще-використовувати-абстрактний-клас-а-в-яких--інтерфейс)
+ [Опишіть приклад, де доцільно застосувати _композицію_ замість _успадкування_.](#опишіть-приклад-де-доцільно-застосувати-композицію-замість-успадкування)
+ [Як за допомогою ООП реалізувати _систему розрахунку заробітної плати_ для працівників різних типів?](#як-за-допомогою-ооп-реалізувати-систему-розрахунку-заробітної-плати-для-працівників-різних-типів)
+ [Чи можна реалізувати _інкапсуляцію без використання модифікаторів доступу_?](#чи-можна-реалізувати-інкапсуляцію-без-використання-модифікаторів-доступу)
+ [Як виглядає _UML-діаграма класів_ для прикладу з наслідуванням і композицією?](#як-виглядає-uml-діаграма-класів-для-прикладу-з-успадкуванням-і-композицією)
+ [Чи є можливість створити _повністю незмінний об'єкт (Immutable)_? Як це вписується в ООП?](#чи-є-можливість-створити-повністю-незмінний-обєкт-immutable-як-це-вписується-в-ооп)

---


## Що таке об’єктно-орієнтоване програмування (ООП)?

**Об’єктно-орієнтоване програмування (ООП)** — це парадигма (методологія) програмування, в основі якої лежить представлення програми у вигляді **сукупності об’єктів**, кожен з яких є **екземпляром певного класу**, а класи утворюють **ієрархію наслідування**.

### Основні принципи ООП:

1. **Інкапсуляція**  
   Приховування внутрішньої реалізації об'єкта від зовнішнього світу. Всі взаємодії відбуваються через публічні методи (інтерфейс).

2. **Наслідування**  
   Можливість створення нового класу на основі вже існуючого. Новий клас успадковує поля та методи батьківського класу.

3. **Поліморфізм**  
   Можливість об’єктів поводитись по-різному при виклику одного й того ж методу (в залежності від фактичного типу об’єкта).

4. **Абстракція**  
   Виділення суттєвих характеристик об’єкта та приховування несуттєвих деталей. Дає змогу працювати з об’єктами на більш високому рівні узагальнення.

### Основні поняття ООП:

- **Клас** — шаблон (опис), за яким створюються об’єкти.
- **Об’єкт** — екземпляр класу.
- **Метод** — функція, яка визначає поведінку об’єкта.
- **Поле (змінна класу)** — характеристика (стан) об’єкта.

> Програма вважається об'єктно-орієнтованою, **тільки якщо дотримано всі три ключові вимоги**:
> - використовуються **об'єкти як основні логічні елементи**, а не алгоритми,
> - кожен об'єкт є **екземпляром класу**,
> - класи утворюють **ієрархію** (тобто підтримується **успадкування**).

> Якщо успадкування не використовується, то це вже **не ООП**, а **програмування з використанням абстрактних типів даних**.

### Приклад (Java):

```java
class Animal {
    String name;

    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    void speak() {
        System.out.println("Dog barks");
    }
}

Animal a = new Dog();
a.speak(); // Виведе: Dog barks (поліморфізм)
```

### Поведінка об’єктів в ООП

Згідно з парадигмою ООП, програма складається з **об’єктів, які обмінюються повідомленнями**.

- Об’єкти можуть **мати стан** (зберігати дані).
- Єдиний спосіб **змінити стан об’єкта** — **послати йому повідомлення** (тобто викликати метод).
- У відповідь на повідомлення об’єкт **може змінити свій стан або виконати дію**.

Цей підхід дозволяє створювати модульні, розширювані й керовані програми.


---

## Які основні принципи ООП?

1. **Інкапсуляція** — приховування реалізації. Об'єкт приховує внутрішні деталі та надає доступ до них тільки через публічні методи.

2. **Наслідування** — створення нової сутності на основі вже існуючої. Дочірній клас наслідує властивості та поведінку батьківського.

3. **Поліморфізм** — можливість мати різні форми для однієї й тієї ж сутності. Один і той самий метод може поводитися по-різному в залежності від контексту.

4. **Абстракція** — набір суттєвих загальних характеристик, що дозволяє працювати з об’єктами на високому рівні узагальнення без деталізації реалізації.

5. **Посилка повідомлень** — форма зв’язку та взаємодії між об’єктами. Об'єкти надсилають одне одному повідомлення (виклики методів) для виконання дій.

6. **Повторне використання (реюз)** — всі попередні принципи забезпечують можливість ефективного повторного використання коду.

> Це єдино правильний порядок принципів ООП, оскільки кожен наступний базується на попередньому.

---


## Що таке інкапсуляція?

**Інкапсуляція** — це властивість об’єктно-орієнтованої системи, яка дозволяє **об’єднати дані (поля) та методи, що з ними працюють, у класі**, і **приховати реалізаційні деталі** від зовнішнього світу. Зовнішнім користувачам відкривається лише те, що необхідне для взаємодії з об’єктом.

### Мета інкапсуляції:
- **Зменшити залежність** зовнішнього коду від внутрішньої реалізації класу.
- **Захистити** внутрішній стан об’єкта від неправильного використання.
- **Дати змогу змінювати реалізацію без зміни зовнішнього інтерфейсу**.

> Якщо змінюється внутрішня логіка класу, але зовнішній інтерфейс залишається незмінним — інші частини програми не постраждають.

### Приклад з життя:

Уявіть собі автомобіль 19 століття, що працює на парі. Для його водіння треба:
- постійно слідкувати за рівнем води та температурою,
- підкидати вугілля,
- управляти колесами через окремі важелі.

Сучасна машина працює так само — там є паливна система, двигун, передача моменту, поворот коліс — **але водієві все це не потрібно знати**. Він просто:
- натискає педаль газу,
- крутить кермо.

**Складна реалізація схована**, і це дозволяє використовувати автомобіль навіть тим, хто ніколи не вивчав механіку. **Це і є інкапсуляція** — приховання деталей реалізації та відкриття лише потрібного інтерфейсу.

### Приклад на Java:

```java
public class AbstractPhone {

    private int year;
    private String company;

    public AbstractPhone(int year, String company) {
        this.year = year;
        this.company = company;
    }

    private void openConnection() {
        // findComutator
        // openNewConnection...
    }

    public void call() {
        openConnection();
        System.out.println("Виклик номера");
    }

    public void ring() {
        System.out.println("Дзень-дзень");
    }
}
```

- Поля `year` та `company`, а також метод `openConnection()` — **закриті** (`private`). Це означає, що вони **недоступні зовні**.
- Метод `call()` **публічний** (`public`) і надає **контрольований доступ** до функціональності телефону.
- **Внутрішню логіку** методу `openConnection()` можна змінити, не побоюючись, що це зламає інші частини програми.

### Висновок:

Інкапсуляція:
- приховує складність,
- захищає об’єкт,
- дозволяє змінювати реалізацію без ризику для інших компонентів,
- забезпечує чіткий і безпечний інтерфейс для взаємодії з об'єктом.

Це **один із ключових принципів ООП**, без якого неможливо створити надійну та гнучку систему.

---

## Що таке наслідування?

**Наслідування** — це властивість об’єктно-орієнтованої системи, яка дозволяє **описати новий клас на основі вже існуючого**, **успадковуючи його властивості та поведінку** частково або повністю.

- Клас, від якого відбувається наслідування, називається **батьківським**, **базовим** або **предком**.
- Новий клас, що наслідує, називається **нащадком**, **похідним** або **дочірнім класом**.

### Мета наслідування:
- Повторне використання коду без дублювання.
- Розширення або модифікація вже існуючої функціональності.
- Побудова ієрархії типів (класифікація об’єктів).

### Приклад із життя:

Уявімо, що ми — інженери на автомобільному заводі. Ми маємо успішну стару модель автомобіля, яка добре себе зарекомендувала. Замість того, щоб створювати нову модель з нуля, ми беремо за основу стару конструкцію та:
- додаємо гідропідсилювач керма,
- оновлюємо фари,
- змінюємо форму кузова.

Ми створюємо **нові модифікації** (седан, універсал, хетчбек), які **успадковують більшість характеристик** базової моделі, але також мають свої унікальні риси. Це і є **наслідування** — використання старого як основи для створення нового з мінімальними зусиллями.

### Приклад на Java:

```java
// Базовий клас: бездротовий телефон
public abstract class WirelessPhone extends AbstractPhone {

    private int hour;

    public WirelessPhone(int year, int hour) {
        super(year);
        this.hour = hour;
    }
}
```

```java
// Похідний клас: мобільний телефон
public class CellPhone extends WirelessPhone {
    public CellPhone(int year, int hour) {
        super(year, hour);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Викликаю номер " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Дзвонить абонент " + inputNumber);
    }
}
```

```java
// Похідний клас: смартфон
public class Smartphone extends CellPhone {

    private String operationSystem;

    public Smartphone(int year, int hour, String operationSystem) {
        super(year, hour);
        this.operationSystem = operationSystem;
    }

    public void install(String program) {
        System.out.println("Встановлюю " + program + " для " + operationSystem);
    }
}
```

### Пояснення:

- `Smartphone` наслідує `CellPhone`, який наслідує `WirelessPhone`.
- Ми **розширюємо функціональність**: кожен новий клас додає щось своє (наприклад, операційну систему та метод `install()`).
- Завдяки наслідуванню ми не дублюємо код, а лише додаємо нові можливості.

### Висновок:

Наслідування:
- дозволяє створювати нові класи на базі існуючих,
- сприяє повторному використанню коду,
- забезпечує логічну ієрархію об’єктів,
- зменшує обсяг коду та спрощує його підтримку.

Це один із базових принципів ООП, що дає змогу легко масштабувати програмні рішення.

---


## Що таке поліморфізм?

**Поліморфізм** — це здатність системи використовувати **об’єкти з однаковим інтерфейсом без знання їх точного типу** або внутрішньої структури. Інакше кажучи, програма може взаємодіяти з об'єктами через спільний інтерфейс, а **реальна поведінка визначається під час виконання**.

### Мета поліморфізму:
- **Зменшити складність** системи.
- **Забезпечити гнучкість** коду.
- **Використовувати спільний інтерфейс** для об'єктів різних класів.
- **Замінювати об’єкти базового класу на об’єкти його нащадків**, не змінюючи логіку програми.

### Приклад з життя:

Усі автомобілі мають **один і той самий інтерфейс керування**: кермо, педалі, коробка передач. Людина, яка навчилася водити один тип автомобіля, зможе легко сісти за кермо іншого — **оскільки вона працює з уніфікованим інтерфейсом**, незалежно від внутрішньої реалізації машини.

> Так і в ООП: об'єкти мають спільний інтерфейс (наприклад, метод `call()`), але реалізують його по-своєму.

### Види поліморфізму:

1. **Ad hoc (випадковий)** — метод поводиться по-різному для різних типів:
   > Наприклад, `draw()` малює коло або квадрат по-різному.

2. **Параметричний** — метод працює однаково з аргументами різних типів:
   > Наприклад, `add()` додає в контейнер будь-який об’єкт.
   
### Приклад на Java:

```java
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public void callAnotherUser(int number, AbstractPhone phone) {
        phone.call(number); // Ось він — поліморфізм!
    }
}
```

```java
public class ThomasEdisonPhone extends AbstractPhone {
    public ThomasEdisonPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Крутіть ручку");
        System.out.println("Назвіть номер абонента, сер");
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон дзвонить");
    }
}
```

```java
public class Phone extends AbstractPhone {
    public Phone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Викликаю номер " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон дзвонить");
    }
}
```

```java
public class VideoPhone extends AbstractPhone {
    public VideoPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Підключаю відеоканал для абонента " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("У вас відеодзвінок від " + inputNumber);
    }
}
```

```java
// Приклад використання
AbstractPhone firstPhone = new ThomasEdisonPhone(1879);
AbstractPhone phone = new Phone(1984);
AbstractPhone videoPhone = new VideoPhone(2018);
User user = new User("Андрій");

user.callAnotherUser(224466, firstPhone);
// Крутіть ручку
// Назвіть номер абонента, сер

user.callAnotherUser(224466, phone);
// Викликаю номер 224466

user.callAnotherUser(224466, videoPhone);
// Підключаю відеоканал для абонента 224466
```

У кожному з трьох викликів використовується **один і той самий метод `callAnotherUser()`**, але результат — різний, бо **реальна реалізація `call()` визначається динамічно**, залежно від типу об’єкта. Це і є **динамічний поліморфізм**.

### Перевизначення методів

Механізм поліморфізму реалізується через **перевизначення методів** — тобто заміну методу базового класу у підкласі з тією ж сигнатурою. У Java для цього використовується анотація `@Override`.

### Висновок:

Поліморфізм:
- дозволяє писати гнучкий, масштабований код;
- дає змогу працювати з об’єктами через загальний інтерфейс;
- забезпечує **реалізацію одного й того ж методу різними способами**;
- базується на **наслідуванні та абстракції**.

Це — один із ключових принципів ООП, що дає змогу створювати зручні та універсальні програмні моделі.

---

## Що таке абстракція?

**Абстракція** — це процес **виділення суттєвих характеристик об'єкта** та **ігнорування несуттєвих або другорядних деталей**. У результаті ми отримуємо **узагальнене уявлення про об'єкт**, яке зручно використовувати у програмі.

### Мета абстракції:
- Спрощення сприйняття складної системи.
- Зосередження уваги на головному, без занурення в технічні деталі.
- Надання загального інтерфейсу для взаємодії з об'єктами різних типів.

### Приклад з життя:

Уявіть водія, який їде автомобілем у міському трафіку. У цей момент він:
- **не думає** про хімічний склад фарби машини,
- **не замислюється** над тим, як працюють шестерні коробки передач,
- **не аналізує** форму кузова.

Він зосереджений лише на **важливих речах**:
- крутить кермо,
- тисне на педалі,
- вмикає поворотники.

> Ці елементи керування — **абстракція** автомобіля. Водієві не потрібно знати, що відбувається "під капотом", щоб керувати.

### Приклад на Java:

```java
// Абстрактний клас
abstract class Animal {
    // Абстрактний метод (без тіла)
    public abstract void animalSound();

    // Звичайний метод
    public void sleep() {
        System.out.println("Zzz");
    }
}

// Підклас, який реалізує абстрактний метод
class Pig extends Animal {
    public void animalSound() {
        System.out.println("Свиня каже: хрю-хрю");
    }
}

class MyMainClass {
    public static void main(String[] args) {
        Pig myPig = new Pig();      // Створюємо об'єкт
        myPig.animalSound();        // Виведе: Свиня каже: хрю-хрю
        myPig.sleep();              // Виведе: Zzz
    }
}
```

### Пояснення:
- Клас `Animal` містить **абстрактний метод `animalSound()`**, який не має тіла.
- Підклас `Pig` **реалізує цей метод**, визначаючи конкретну поведінку.
- Клас `Animal` виступає як **інтерфейс взаємодії**, який приховує реалізацію.
- Завдяки цьому ми можемо створювати нові підкласи (`Cat`, `Dog`, `Cow` тощо), не змінюючи базовий інтерфейс.

### Висновок:

**Абстракція**:
- дозволяє створювати узагальнені інтерфейси,
- приховує складні деталі реалізації,
- забезпечує спрощену модель взаємодії з об'єктами,
- є ключовим принципом для реалізації масштабованих і підтримуваних систем.

> В ООП **абстракція тісно пов'язана з інтерфейсами та абстрактними класами**, які дозволяють описувати, *що саме має робити об'єкт*, а не *як саме він це робить*.

---

## Що таке обмін повідомленнями в ООП?

**Обмін повідомленнями** — це механізм взаємодії об’єктів в об’єктно-орієнтованому програмуванні. Об’єкти спілкуються між собою **через надсилання та отримання повідомлень**, тобто виклики методів.

### Що таке повідомлення?

**Повідомлення** — це запит об’єкту на виконання певної дії (виклик методу), який може містити аргументи, необхідні для виконання цієї дії.

> У термінах програмування повідомлення — це **виклик методу об’єкта** з певними параметрами.

### Як це працює:

- Коли один об’єкт викликає метод іншого — він **надсилає йому повідомлення**.
- Об’єкт, який отримав повідомлення, **реагує на нього**, виконуючи відповідну дію.
- Щоб об’єкт міг "відповісти", у нього має бути **метод з відповідним іменем**.
- Об’єкти також можуть у відповідь **надсилати повідомлення іншим об’єктам**.

### Відмінність від традиційного підходу

У традиційному (процедурному) програмуванні:
- Існує **одна загальна функція**, наприклад, `bounce(ballId)`, яка обробляє дані кулі, передані через індекс або ідентифікатор.

В ООП:
- Кожна куля — це **окремий об’єкт** із власними властивостями та методом `bounce()`.
- Замість передачі ідентифікатора кулі у функцію, ми просто **надсилаємо повідомлення (виклик методу) конкретному об’єкту**:

```java
ball3.bounce();
```

> У такий спосіб кожен об'єкт **сам відповідає за свою поведінку**.

### Приклад:

```java
class Ball {
    private double radius;

    public Ball(double radius) {
        this.radius = radius;
    }

    public void bounce() {
        System.out.println("Куля з радіусом " + radius + " підскочила!");
    }
}

// У головному методі
Ball ball1 = new Ball(5.0);
Ball ball2 = new Ball(10.0);

ball1.bounce(); // Надсилаємо повідомлення об'єкту ball1
ball2.bounce(); // Надсилаємо повідомлення об'єкту ball2
```

### Технічна особливість

У Java виклики методів (тобто обмін повідомленнями) реалізуються через **динамічне зв’язування (late binding)** — це означає, що програма визначає, який саме метод викликати **під час виконання**, а не під час компіляції. Це забезпечує **гнучкість і підтримку поліморфізму**.

### Висновок:

- **Обмін повідомленнями** — це ключовий механізм взаємодії об'єктів в ООП.
- Він дозволяє об'єктам керувати поведінкою один одного через виклики методів.
- Це забезпечує **низьку зв’язаність**, **модульність**, **гнучкість** та **розширюваність** коду.
- На відміну від процедурного стилю, **поведінка об'єкта інкапсулюється всередині самого об’єкта**, що є однією з головних переваг ООП.

---

## У чому різниця між класом і об’єктом?

У об'єктно-орієнтованому програмуванні **клас** і **об’єкт** — це два фундаментальні поняття, які тісно пов’язані між собою, але виконують різні ролі.

### Клас

**Клас** — це **шаблон або креслення**, за яким створюються об’єкти. Він описує:
- які **дані (поля)** матиме об’єкт,
- яку **поведінку (методи)** він може виконувати.

> Клас — це **абстракція**, яка не займає пам’яті до моменту створення об’єкта.

### Об’єкт

**Об’єкт** — це **конкретний екземпляр класу**, який вже існує в пам’яті під час виконання програми.

Об’єкт:
- має **свій стан** (конкретні значення полів),
- може виконувати **методи**, визначені у класі.

### Порівняння:

| Ознака         | Клас                             | Об’єкт                                      |
|----------------|----------------------------------|---------------------------------------------|
| Що це          | Шаблон, опис                     | Реалізація, екземпляр класу                 |
| Існування      | Ідея, не займає пам’яті          | Існує під час виконання, займає пам’ять     |
| Мета           | Описує структуру та поведінку    | Втілює поведінку, працює з даними           |
| Приклад (Java) | `class Car { ... }`              | `Car myCar = new Car();`                    |

### Приклад:

```java
class Car {
    String color;
    void drive() {
        System.out.println("Авто їде");
    }
}

Car car1 = new Car(); // car1 — об’єкт класу Car
car1.color = "червоний";
car1.drive(); // Виведе: Авто їде
```

- `Car` — клас, який описує, що таке автомобіль.
- `car1` — об’єкт, конкретний автомобіль з кольором та поведінкою.

### Висновок:

- **Клас** — це опис *що таке об'єкт*.
- **Об’єкт** — це *реалізація* цього опису під час виконання.
- Один клас може використовуватись для створення **багатьох об’єктів**.
- Без класів немає об’єктів, але без об’єктів класи не мають практичного сенсу.

> Клас — це те, що ми проектуємо. Об’єкт — це те, з чим ми працюємо.

---

## Що таке інтерфейс і як він використовується в ООП?

**Інтерфейс** в об’єктно-орієнтованому програмуванні — це **контракт**, який визначає **набір методів**, що мають бути реалізовані класами, які цей інтерфейс імплементують. Він описує **"що саме має бути зроблено"**, але не **"як саме це зробити"**.

### Основні властивості інтерфейсу:

- **Не містить реалізації** методів (до Java 8) або містить лише **дефолтну/статичну реалізацію** (починаючи з Java 8).
- Може містити **константи** (поля `public static final`).
- Клас, який реалізує інтерфейс, **зобов’язаний реалізувати всі його методи**.

> Інтерфейс — це чиста абстракція. Він не знає нічого про реалізацію, лише вимагає дотримання форми.

### Навіщо потрібні інтерфейси:

- Для **створення єдиної точки взаємодії** з об’єктами різних типів.
- Для **реалізації поліморфізму**.
- Для **розділення обов’язків** і **гнучкої архітектури**.
- Для **тестування**, де можна легко підмінити реалізацію (наприклад, на мок).

### Приклад на Java:

```java
// Оголошення інтерфейсу
public interface Animal {
    void makeSound();
}
```

```java
// Клас, який реалізує інтерфейс
public class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Гав-гав");
    }
}

public class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Няв");
    }
}
```

```java
// Використання
public class Zoo {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();

        dog.makeSound(); // Виведе: Гав-гав
        cat.makeSound(); // Виведе: Няв
    }
}
```

### Пояснення:

- `Animal` — інтерфейс, який гарантує, що всі тварини можуть видавати звук.
- `Dog` і `Cat` реалізують `makeSound()` по-своєму.
- Об'єкти різних класів можуть використовуватись через **одну й ту саму змінну типу `Animal`**.

### Висновок:

- **Інтерфейс** — це спосіб **описати поведінку**, яку мають реалізовувати різні класи.
- Він дозволяє **відокремити реалізацію від визначення**, створюючи **гнучку, масштабовану та поліморфну архітектуру**.
- У Java, один клас може **реалізовувати багато інтерфейсів**, що дає змогу уникати обмежень одиничного наслідування.

> Інтерфейси — ключовий інструмент створення гнучкого та модульного коду в ООП.

---

## Що означає реалізує інтерфейс (implements interface)?

У мовах об’єктно-орієнтованого програмування, таких як Java, коли клас **реалізує інтерфейс** (ключове слово `implements`), це означає, що **клас зобов’язується надати конкретну реалізацію всіх методів, оголошених в інтерфейсі**.

> Інтерфейс визначає **"що потрібно зробити"**, а клас реалізує **"як саме це буде зроблено"**.

### Синтаксис Java:

```java
public interface Vehicle {
    void drive();
}
```

```java
public class Car implements Vehicle {
    @Override
    public void drive() {
        System.out.println("Автомобіль їде");
    }
}
```

- `Vehicle` — це інтерфейс.
- `Car` — клас, який **реалізує** інтерфейс `Vehicle`.
- Ключове слово `implements` вказує, що `Car` **виконує контракт**, заданий інтерфейсом `Vehicle`.
- Клас `Car` зобов'язаний реалізувати метод `drive()`.

### Ключові особливості:

- Один клас може **реалізовувати кілька інтерфейсів**, розділених комами:

```java
public class Smartphone implements Camera, GPS, Phone { ... }
```

- Це дозволяє **досягати множинної поведінки** (на відміну від класичного успадкування, яке обмежене одним батьківським класом).

### Навіщо реалізовувати інтерфейси?

- Щоб **забезпечити спільний інтерфейс** для різних класів.
- Для реалізації **поліморфізму**: об'єкти різних класів можна використовувати однаково.
- Для **розділення логіки** та **спрощення тестування** (наприклад, легко підмінити реалізацію на мок).
- Для **гнучкої архітектури**: можна змінити реалізацію без зміни контракту.

### Висновок:

Коли клас **реалізує інтерфейс**, він:
- **дотримується контракту**, визначеного інтерфейсом,
- **гарантує наявність методів**, потрібних для взаємодії,
- забезпечує **гнучку, масштабовану структуру програми**.

> Реалізація інтерфейсу — це спосіб "пообіцяти", що клас підтримує певну поведінку, і дотримати цієї обіцянки за допомогою власної реалізації.

---

## Що означає успадковує клас (extends class)?

Коли один клас **успадковує інший клас** (використовуючи ключове слово `extends`), це означає, що **новий клас (нащадок) автоматично отримує всі публічні та захищені (protected) поля й методи батьківського класу**, а також може **розширювати або змінювати їхню поведінку**.

> Іншими словами, клас-нащадок **переймає функціональність батьківського класу**, з можливістю її змінити чи доповнити.

### Основи синтаксису (Java):

```java
public class Animal {
    public void makeSound() {
        System.out.println("Some generic sound");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof");
    }
}
```

- `Dog` **успадковує** клас `Animal` через `extends`.
- Метод `makeSound()` у `Dog` **перевизначає** метод з базового класу.

### Ключові особливості:

- Клас-нащадок має доступ до всіх **публічних і захищених** методів/полів батьківського класу.
- Може додавати **власні методи й поля**.
- Може **перевизначати методи** (override) з батьківського класу.
- **Не успадковуються приватні (`private`) елементи** базового класу.
- Java підтримує **тільки одиничне успадкування** між класами (один батьківський клас).

### Приклад:

```java
class Vehicle {
    public void drive() {
        System.out.println("Рухається транспорт");
    }
}

class Car extends Vehicle {
    @Override
    public void drive() {
        System.out.println("Автомобіль їде");
    }
}
```

```java
Vehicle v = new Car();
v.drive(); // Виведе: Автомобіль їде
```

### Висновок:

- Ключове слово `extends` вказує, що **клас-нащадок базується на існуючому класі**.
- Це основа **наслідування в ООП**, що дозволяє:
   - **повторно використовувати код**,
   - **організовувати ієрархію класів**,
   - реалізовувати **поліморфізм**.
- Наслідування дає змогу створювати **спеціалізовані класи** на основі більш загальних.

> `extends` — це міст між базовим функціоналом і його розширеною версією.

---

## Що таке конструктор? Які бувають типи конструкторів?

**Конструктор** — це спеціальний метод класу, який викликається автоматично при створенні нового об’єкта. Його основна мета — **ініціалізувати об’єкт**, тобто надати початкові значення змінним екземпляра або виконати необхідні дії під час створення.

Конструктор має такі характеристики:
- Назва конструктора **збігається з назвою класу**.
- Не має **повертаного типу** (навіть `void`).
- Може бути перевантаженим (тобто в класі може бути кілька конструкторів з різними параметрами).

### Типи конструкторів

#### За замовчуванням (default constructor)

Це конструктор без параметрів, який створюється автоматично компілятором, якщо не вказано жодного явного конструктора.

```java
class Person {
    String name;
}
Person p = new Person(); // Виклик конструктора за замовчуванням
```

#### Явно визначений (explicit constructor)

Це конструктор, створений програмістом, з параметрами або без. Якщо хоча б один явний конструктор задано, конструктор за замовчуванням вже не створюється автоматично.

```java
class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }
}
Person p = new Person("Олена");
```

#### Перевантажений (overloaded constructor)

Це кілька конструкторів в одному класі з різними списками параметрів. Дозволяє створювати об’єкти з різними варіантами ініціалізації.

```java
class Rectangle {
    int width, height;

    public Rectangle() {
        this.width = 1;
        this.height = 1;
    }

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

#### Приватний конструктор

Використовується, коли потрібно обмежити створення об’єктів (наприклад, у шаблоні Singleton).

```java
class Singleton {
    private static Singleton instance;
    private Singleton() {} // приватний конструктор

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### Висновок

Конструктори є важливою частиною класів в ООП. Вони дозволяють забезпечити правильну ініціалізацію об’єктів і надати гнучкість у створенні екземплярів з різними параметрами. Розумне використання конструкторів підвищує надійність і зрозумілість коду.

---

## У чому полягають переваги та недоліки ООП?

### Переваги об’єктно-орієнтованого програмування

- **Природність об’єктної моделі**. ООП відображає реальний світ і орієнтоване на людське сприйняття, а не лише на комп’ютерну реалізацію. Об’єкти моделюють сутності з властивостями та поведінкою, що відповідає нашому способу мислення.

- **Абстрагування від реалізації**. Класи дозволяють створювати програму з незалежних компонентів. Розробники можуть використовувати функціонал, не знаючи деталей реалізації.

- **Локалізація коду та даних**. Дані та методи, що працюють із цими даними, зосереджені в одному місці — в межах об’єкта. Це покращує читаність, спрощує супровід і знижує ризик помилок.

- **Інкапсуляція і модульність**. Кожен об’єкт приховує свою реалізацію. Це дозволяє змінювати внутрішню логіку, не порушуючи роботу інших частин програми. ООП підтримує модульний підхід, що спрощує розподіл роботи, тестування та оновлення окремих компонентів.

- **Розширюваність систем**. Наслідування дозволяє створювати нові класи на основі вже існуючих, розширюючи або змінюючи їхню поведінку без дублювання коду.

- **Поліморфізм**:
    - Дозволяє працювати з різними об’єктами через єдиний інтерфейс, спрощуючи код.
    - Дає змогу змінювати поведінку під час виконання — об’єкт одного типу можна замінити іншим без змін у викликаючому коді.
    - Дозволяє узагальнювати алгоритми для роботи з об'єктами різних типів.

- **Можливість створення фреймворків**. ООП дозволяє описувати незалежні від конкретного застосунку частини предметної області у вигляді базових класів та компонентів, які згодом можна розширити під потреби проєкту.

- **Повторне використання коду**:
    - Зменшує час розробки, дозволяючи зосередитись на бізнес-логіці.
    - Компоненти багаторазового використання краще протестовані і містять менше помилок.
    - Поліпшення в одному спільному компоненті одразу приносять користь багатьом системам.
    - Використання стандартних компонентів уніфікує інтерфейси та архітектуру, спрощуючи підтримку.

### Недоліки об’єктно-орієнтованого програмування

- **Складність ієрархій**. У великих проєктах із глибоким наслідуванням важко відслідковувати, які саме поля і методи успадковуються, і як вони взаємодіють.

- **Розподіленість логіки**. Обробка одного повідомлення може бути розпорошена між кількома методами в різних класах, що ускладнює розуміння програми.

- **Ускладнена документація**. Унаслідок можливості перевизначення методів, документація має не лише описувати метод, а й пояснювати його контекст, поведінку в підкласах і вплив на інші компоненти.

- **Зниження продуктивності**. Використання динамічного зв’язування і перевірок типів під час виконання вимагає додаткових ресурсів, що може впливати на швидкодію та ефективність пам’яті.
- 
- **Надмірна універсальність**. Класи можуть містити більше методів, ніж реально потрібно, що призводить до "мертвого" коду, який ніколи не використовується, але займає місце і ускладнює підтримку.

### Висновок

Об’єктно-орієнтоване програмування має багато переваг, особливо в контексті масштабованих, підтримуваних і гнучких систем. Проте його використання потребує уважного проєктування, щоб уникнути надмірної складності та неефективності. При правильному застосуванні ООП значно полегшує розробку, підтримку та розвиток програмного забезпечення.

---

## Яка роль модифікаторів доступу (private, protected, public) у реалізації інкапсуляції?

### Роль модифікаторів доступу в інкапсуляції

**Інкапсуляція** передбачає приховування внутрішньої реалізації класу та контрольований доступ до його даних і методів. Для реалізації цього механізму в об'єктно-орієнтованому програмуванні використовуються **модифікатори доступу**, які визначають рівень доступності елементів класу (полів, методів, конструкторів тощо).

### public

Модифікатор `public` надає **повний доступ** до члена класу з будь-якого іншого класу або пакета. Він використовується для відкритих частин інтерфейсу класу, до яких повинні мати доступ інші об’єкти.

```java
public class Car {
    public void start() {
        System.out.println("Автомобіль заведено");
    }
}
```

Метод `start()` доступний будь-де у програмі.

### private

Модифікатор `private` дозволяє доступ **лише зсередини того ж класу**. Це головний інструмент **приховування реалізації**. Завдяки `private` ми можемо захистити дані від небажаного прямого доступу та зміни ззовні.

```java
public class Account {
    private double balance;

    public void deposit(double amount) {
        balance += amount;
    }
}
```

Поле `balance` недоступне напряму — лише через метод `deposit()`.

### protected

Модифікатор `protected` дозволяє доступ:
- у межах того ж класу,
- у підкласах (навіть якщо вони в іншому пакеті),
- у межах одного пакета.

Він забезпечує баланс між повною закритістю `private` і відкритістю `public`, дозволяючи **розширювати клас через наслідування**, не розкриваючи все для зовнішнього світу.

```java
public class Animal {
    protected void breathe() {
        System.out.println("Тварина дихає");
    }
}
```

### Висновок

Модифікатори доступу є ключовим механізмом реалізації інкапсуляції. Вони дозволяють:
- приховати внутрішню реалізацію об'єкта (`private`),
- обмежити доступ до членів класу в рамках ієрархії (`protected`),
- надати відкритий доступ до важливих частин інтерфейсу (`public`).

Правильне використання модифікаторів доступу дозволяє зробити код більш безпечним, зрозумілим і зручним у підтримці.

---

## У чому різниця між перевантаженням (overloading) та перевизначенням (overriding) методів?

### Перевантаження (overloading)

**Перевантаження методу** означає створення в одному класі кількох методів з однаковим ім’ям, але з різними списками параметрів (типами, кількістю або порядком аргументів). Це дозволяє використовувати одну назву методу для різних варіантів його виклику.

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

Усі три методи мають однакову назву `add`, але приймають різні параметри. Це дозволяє зручно використовувати метод без потреби запам’ятовувати різні імена.

- Відбувається **в межах одного класу**.
- Визначається **на етапі компіляції** (статичний поліморфізм).
- Не враховується тип повернення — лише параметри.

### Перевизначення (overriding)

**Перевизначення методу** — це надання нової реалізації методу, який успадковується від батьківського класу. Метод у підкласі має таку саму сигнатуру (ім’я, параметри, тип повернення), як і в батьківському класі.

```java
class Animal {
    public void makeSound() {
        System.out.println("Тварина видає звук");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Гав");
    }
}
```

Метод `makeSound()` у класі `Dog` **перевизначає** метод із класу `Animal`.

- Відбувається **між класами в ієрархії наслідування**.
- Визначається **під час виконання програми** (динамічний поліморфізм).
- Дозволяє змінити або розширити поведінку батьківського класу.

### Основні відмінності

| Ознака                    | Перевантаження (overloading)         | Перевизначення (overriding)           |
|---------------------------|---------------------------------------|----------------------------------------|
| Де використовується       | У межах одного класу                 | У класі-нащадку щодо батьківського     |
| Зміна параметрів          | Обов’язкова                          | Ні, сигнатура методу не змінюється     |
| Зміна реалізації          | Так, для кожної версії               | Так, для успадкованого методу          |
| Час визначення            | Під час компіляції                   | Під час виконання                      |
| Поліморфізм               | Статичний                            | Динамічний                             |

### Висновок

- **Перевантаження** — це зручність виклику методів з різними параметрами під одним ім’ям.
- **Перевизначення** — це механізм зміни поведінки методу батьківського класу в дочірньому класі.
- Обидва підходи є формами поліморфізму, але реалізуються по-різному.

---

## Що таке dynamic dispatch (динамічна диспетчеризація)?

### Що таке dynamic dispatch (динамічна диспетчеризація)

**Динамічна диспетчеризація** — це механізм, який дозволяє програмі вирішити, яку саме реалізацію перевизначеного методу викликати, **під час виконання**, а не під час компіляції. Це ключовий компонент **динамічного (пізнього) зв’язування** та **поліморфізму** в об’єктно-орієнтованому програмуванні.

У мовах, як-от Java, якщо метод перевизначений у підкласі, то яка саме версія методу буде викликана — визначається **за фактичним типом об’єкта**, а не типом змінної, що його зберігає.

### Приклад на Java

```java
class Animal {
    void makeSound() {
        System.out.println("Тварина видає звук");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Гав");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog(); // тип змінної — Animal, але об'єкт — Dog
        a.makeSound(); // Виведе: Гав
    }
}
```

У цьому прикладі:
- Метод `makeSound()` перевизначено в класі `Dog`.
- Хоча змінна `a` має тип `Animal`, насправді вона посилається на об’єкт `Dog`.
- Завдяки динамічній диспетчеризації, під час виконання буде викликано саме `Dog.makeSound()`.

### Як це працює

Під час компіляції програма не знає точного типу об’єкта, на який посилається змінна. Але під час виконання JVM використовує **віртуальну таблицю (vtable)**, щоб визначити, яку реалізацію методу викликати.

### Чому це важливо

- Забезпечує **реалізацію поліморфізму**.
- Дозволяє створювати **гнучкі та розширювані програми**, в яких поведінка залежить від фактичного типу об’єкта.
- Дає змогу використовувати **загальні інтерфейси або базові класи** для взаємодії з різними об’єктами.

### Висновок

Динамічна диспетчеризація — це основа роботи поліморфізму в ООП. Вона дозволяє вирішити, яку реалізацію методу слід викликати, динамічно — в залежності від фактичного типу об’єкта, що забезпечує гнучкість і масштабованість програм.

---

## У чому різниця між абстрактним класом та інтерфейсом?

### Абстрактний клас

Абстрактний клас — це клас, який **не можна інстанціювати напряму** (не можна створити його об’єкт), і який може містити як **абстрактні методи** (без реалізації), так і **звичайні методи з реалізацією**. Він використовується, коли потрібно надати **спільну реалізацію** для кількох підкласів, а також змусити їх реалізувати певні методи.

```java
abstract class Animal {
    abstract void makeSound();

    void sleep() {
        System.out.println("Спить...");
    }
}
```

### Інтерфейс

Інтерфейс визначає **контракт**: набір методів, які клас повинен реалізувати. Інтерфейси не можуть зберігати стан (крім `static final` змінних) і до Java 8 не могли мати реалізації методів. Починаючи з Java 8, інтерфейси можуть містити **default** і **static** методи з реалізацією.

```java
interface Movable {
    void move();
}
```

### Основні відмінності

| Ознака                           | Абстрактний клас                         | Інтерфейс                                |
|----------------------------------|------------------------------------------|-------------------------------------------|
| Можливість реалізації методів    | Так, може містити реалізацію             | До Java 8 — ні, з Java 8 — default/static |
| Можна створити об'єкт            | Ні                                       | Ні                                        |
| Поля                             | Будь-які                                 | Лише `public static final`               |
| Наслідування                     | Один абстрактний клас                    | Можна реалізувати кілька інтерфейсів      |
| Конструктори                     | Так                                      | Ні                                        |
| Використання                     | Коли є спільна логіка між підкласами     | Коли потрібен контракт (API)             |

### Коли використовувати

- **Абстрактний клас** — коли потрібно визначити **часткову реалізацію** і зберігати спільні поля/методи між підкласами.
- **Інтерфейс** — коли потрібно лише визначити **поведінку**, яку мають реалізувати різні класи (навіть ті, що не мають спільного предка).

### Приклад комбінування

```java
abstract class Animal {
    abstract void makeSound();
}

interface Swimmable {
    void swim();
}

class Dolphin extends Animal implements Swimmable {
    void makeSound() {
        System.out.println("Клікає ультразвуком");
    }

    public void swim() {
        System.out.println("Пливе");
    }
}
```

Клас `Dolphin` успадковує часткову логіку з `Animal` і реалізує додаткову поведінку через інтерфейс `Swimmable`.

---

## Чим відрізняється компіляторне (статичне) та виконуване (динамічне) зв’язування?

### Статичне (компіляторне) зв’язування

**Статичне зв’язування (static binding)** — це процес прив’язки виклику методу до конкретної реалізації, який відбувається **на етапі компіляції**. У цьому випадку компілятор точно знає, який метод буде викликано.

Статичне зв’язування використовується для:
- `private`, `final`, `static` методів;
- методів, які не перевизначаються (не є частиною поліморфізму);
- перевантаження методів (overloading).

```java
class Example {
    static void greet() {
        System.out.println("Hello");
    }
}

Example.greet(); // Статичне зв’язування
```

Перевага — швидкість виконання, оскільки метод визначається під час компіляції.

### Динамічне (виконуване) зв’язування

**Динамічне зв’язування (dynamic binding)** або **пізнє зв’язування (late binding)** — це процес, коли метод, який буде викликаний, визначається **під час виконання програми**, залежно від **фактичного типу об’єкта**.

Динамічне зв’язування використовується для:
- перевизначених методів (`@Override`);
- реалізації **поліморфізму**.

```java
class Animal {
    void makeSound() {
        System.out.println("Some sound");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}

Animal animal = new Cat();
animal.makeSound(); // Динамічне зв’язування
```

У цьому прикладі метод `makeSound()` вибирається динамічно — під час виконання буде викликано метод із класу `Cat`, навіть якщо змінна має тип `Animal`.

### Основні відмінності

| Ознака                         | Статичне зв’язування            | Динамічне зв’язування             |
|-------------------------------|----------------------------------|-----------------------------------|
| Час визначення                 | Під час компіляції               | Під час виконання                 |
| Методи                        | `static`, `final`, `private`    | Звичайні перевизначувані методи  |
| Підтримка поліморфізму         | Ні                               | Так                               |
| Продуктивність                | Вища                             | Може бути нижчою                  |

### Висновок

Статичне зв’язування надає кращу продуктивність, але не підтримує гнучкість, яку забезпечує динамічне зв’язування. Динамічне зв’язування є основою поліморфізму і дозволяє об’єктно-орієнтованим системам бути розширюваними та адаптивними.

---

## Що таке final метод / клас / змінна і як це пов’язано з ООП?

### final-змінна

`final` для змінної означає, що її значення **не можна змінити після ініціалізації**. Це створює **константу**, значення якої не може бути змінено під час виконання програми.

```java
final int DAYS_IN_WEEK = 7;
```

Після присвоєння `DAYS_IN_WEEK = 7`, будь-яка спроба змінити значення цієї змінної викличе помилку компіляції.

### final-метод

Метод, позначений як `final`, **не може бути перевизначений** у підкласах. Це гарантує, що реалізація методу залишиться незмінною і не буде модифікована у спадкоємцях.

```java
class Parent {
    final void sayHello() {
        System.out.println("Привіт від батьківського класу");
    }
}

class Child extends Parent {
    // Неможливо перевизначити sayHello() — буде помилка
}
```

Це корисно, коли потрібно **захистити важливу логіку від зміни**.

### final-клас

Клас, оголошений як `final`, **не може бути успадкований**. Такий клас повністю закритий для розширення.

```java
final class MathUtils {
    // utility methods
}
```

Жоден інший клас не зможе зробити `extends MathUtils`.

### Зв’язок з ООП

Модифікатор `final` підтримує **інкапсуляцію** та **надійність** у об’єктно-орієнтованому програмуванні, обмежуючи зміну логіки та структури:

- final-змінні зменшують ризик помилок, пов’язаних зі зміною стану.
- final-методи захищають реалізацію від небажаного перевизначення.
- final-класи запобігають неправильному або небезпечному наслідуванню.

Це допомагає створювати **стабільний API**, захищати критичну бізнес-логіку та робить систему більш передбачуваною.

---

## Яка роль ключового слова super?

### Використання `super` для доступу до батьківського класу

Ключове слово `super` в Java використовується для **доступу до членів (методів або змінних)** батьківського класу з дочірнього класу.

### Виклик конструктора батьківського класу

За допомогою `super(...)` можна викликати **конструктор батьківського класу**. Це має бути **першим рядком** у конструкторі дочірнього класу.

```java
class Animal {
    Animal(String name) {
        System.out.println("Тварина: " + name);
    }
}

class Dog extends Animal {
    Dog() {
        super("Собака"); // виклик конструктора Animal
    }
}
```

### Доступ до перевизначеного методу батьківського класу

Якщо в підкласі перевизначено метод, але потрібно звернутись до реалізації цього методу з батьківського класу, використовують `super.methodName()`.

```java
class Animal {
    void makeSound() {
        System.out.println("Звук тварини");
    }
}

class Cat extends Animal {
    void makeSound() {
        super.makeSound(); // викликає метод з класу Animal
        System.out.println("Мяу");
    }
}
```

### Доступ до поля батьківського класу

Якщо в підкласі визначено змінну з тим самим іменем, що і в батьківському класі, `super.variableName` дозволяє звернутись саме до **поля з батьківського класу**.

```java
class Parent {
    String name = "Батько";
}

class Child extends Parent {
    String name = "Дитина";

    void printNames() {
        System.out.println(name);        // Дитина
        System.out.println(super.name);  // Батько
    }
}
```

### Переваги `super` в ООП

- Дозволяє **повторно використовувати логіку батьківського класу**.
- Дає змогу **уточнювати або розширювати** поведінку без повного перевизначення.
- Підтримує принцип **успадкування** та **поліморфізму**, надаючи засоби контролю над ієрархією класів.

---

## Як працює механізм пізнього (динамічного) зв'язування в Java?

### Що таке пізнє (динамічне) зв’язування

Пізнє або динамічне зв’язування (late binding / dynamic dispatch) — це механізм, за якого **виклик методу визначається не під час компіляції, а під час виконання програми**, на основі фактичного типу об’єкта.

### Як це працює в Java

У Java всі **не static, не final і не private методи** є кандидатами для пізнього зв’язування. Це означає, що JVM (віртуальна машина Java) під час виконання визначає, **яку саме реалізацію методу викликати**, залежно від **реального типу об’єкта**, а не від типу посилання.

```java
class Animal {
    void sound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Meow");
    }
}

Animal animal = new Dog();
animal.sound(); // Виведе: Bark — виклик методу визначено динамічно
```

У цьому прикладі:
- Змінна `animal` має статичний тип `Animal`
- Але об’єкт, на який вона посилається, є `Dog`
- Під час виконання JVM викликає саме `Dog.sound()`, а не `Animal.sound()`

### Роль в ООП

Пізнє зв’язування є ключовим елементом **поліморфізму**, який дозволяє:
- Використовувати загальні інтерфейси для роботи з різними об’єктами
- Розширювати функціональність без зміни існуючого коду
- Створювати гнучкі та масштабовані системи

### Обмеження

Пізнє зв’язування не застосовується для:
- `static` методів — вони зв’язані на етапі компіляції
- `final` методів — не можуть бути перевизначені
- `private` методів — доступні лише всередині свого класу, не беруть участі в поліморфізмі

### Висновок

Механізм пізнього зв’язування в Java дозволяє реалізувати гнучку поведінку програм, де вибір методу залежить від реального типу об’єкта. Це осн

---

## Що таке instanceof і як воно пов'язане з поліморфізмом?

### Що таке `instanceof`

`instanceof` — це ключове слово в Java, яке використовується для перевірки, **чи є об’єкт екземпляром певного класу або його підкласу (чи реалізує певний інтерфейс)**.

Синтаксис:
```java
object instanceof ClassName
```
Повертає `true`, якщо `object` є об’єктом класу `ClassName` або його нащадком (або реалізує відповідний інтерфейс).

### Приклад:

```java
Animal a = new Dog();

if (a instanceof Dog) {
    System.out.println("Це собака");
}
```

У цьому випадку:
- Змінна `a` має тип `Animal`, але фактично містить об'єкт `Dog`.
- Вираз `a instanceof Dog` поверне `true`.

### Зв’язок з поліморфізмом

Поліморфізм дозволяє використовувати посилання на батьківський тип (`Animal`), щоб працювати з об'єктами підкласів (`Dog`, `Cat` тощо). Але іноді буває необхідно **з’ясувати фактичний тип об’єкта**, щоб виконати спеціалізовану логіку — тут і використовується `instanceof`.

Це дозволяє динамічно реагувати на тип об'єкта, навіть якщо він представлений посиланням батьківського типу:

```java
if (a instanceof Cat) {
    ((Cat) a).purr();
}
```

### Застереження

- Часте використання `instanceof` може свідчити про **поганий дизайн**, оскільки суперечить принципу відкритості/закритості (Open/Closed Principle).
- У більшості випадків замість `instanceof` краще використовувати **поліморфізм напряму** через перевизначені методи.

### Підсумок

`instanceof` дозволяє з’ясувати реальний тип об’єкта під час виконання, що особливо корисно при роботі з поліморфними посиланнями. Проте його слід використовувати обережно та тільки тоді, коли поліморфне перевизначення методів не підходить.

---

## Чим відрізняється shallow copy від deep copy?

### Shallow Copy (поверхневе копіювання)

Shallow copy — це копіювання об’єкта, за якого **копіюються лише примітивні поля** (int, boolean тощо), а **посилання на об’єкти залишаються тими самими**. Тобто, вкладені об’єкти не створюються наново, а спільно використовуються між копією та оригіналом.

```java
class Address {
    String city;
}

class Person implements Cloneable {
    String name;
    Address address;

    public Person clone() throws CloneNotSupportedException {
        return (Person) super.clone(); // shallow copy
    }
}
```

У цьому прикладі:
- `name` буде скопійовано,
- але `address` залишиться спільним для обох екземплярів `Person`.

### Deep Copy (глибоке копіювання)

Deep copy — це копіювання об’єкта разом з **усіма вкладеними об’єктами**. Для кожного об’єкта створюється **новий екземпляр**, включаючи об’єкти, на які посилаються поля.

```java
class Person implements Cloneable {
    String name;
    Address address;

    public Person clone() throws CloneNotSupportedException {
        Person cloned = (Person) super.clone();
        cloned.address = new Address(this.address.city); // глибока копія
        return cloned;
    }
}
```

Тут `address` також буде новим об’єктом, незалежним від оригінального.

### Основні відмінності

| Критерій                | Shallow Copy                        | Deep Copy                                |
|------------------------|-------------------------------------|------------------------------------------|
| Посилання на вкладені об’єкти | Копіюються як є                   | Створюються нові копії                   |
| Примітивні типи         | Копіюються                          | Копіюються                               |
| Залежність              | Копія залежить від оригіналу        | Копія повністю незалежна                 |
| Швидкість               | Швидше                              | Повільніше (більше ресурсів потрібно)   |

### Висновок

- **Shallow copy** підходить, коли вкладені об’єкти не змінюються або використовуються спільно.
- **Deep copy** необхідна, якщо потрібна повна незалежність копії від оригіналу.

---

## Що означають принципи «IS-A» (є) та «HAS-A» (має)?

### Принцип IS-A (є)

Принцип **IS-A** описує відношення **наслідування** між класами. Якщо клас `B` **успадковує** клас `A`, то можна сказати, що `B` **є** `A` (`B IS-A A`).

Це означає, що об'єкт підкласу (`B`) **може використовуватися всюди**, де очікується об'єкт суперкласу (`A`), завдяки **поліморфізму**.

#### Приклад:
```java
class Animal {}
class Dog extends Animal {}
```

Тут:
- `Dog IS-A Animal`
- Об'єкт `Dog` може використовуватися як `Animal`.

```java
Animal a = new Dog(); // коректно
```

### Принцип HAS-A (має)

Принцип **HAS-A** описує відношення **композиції або агрегації** — тобто коли один клас **містить екземпляр іншого класу** як своє поле. Це вказує на те, що **об’єкт має інший об’єкт** у своєму складі.

#### Приклад:
```java
class Engine {}
class Car {
    private Engine engine; // Car HAS-A Engine
}
```

Тут:
- `Car` **має** `Engine`
- Це не наслідування, а **включення** одного об’єкта в інший.

### Порівняння

| Принцип | Відношення          | Приклад                | Використовується для      |
|---------|---------------------|-------------------------|----------------------------|
| IS-A    | Наслідування         | `Dog IS-A Animal`       | Узагальнення, поліморфізм  |
| HAS-A   | Композиція/Агрегація | `Car HAS-A Engine`      | Побудова складних об’єктів |

### Висновок

- IS-A відображає **ієрархічну** модель об’єктів (успадкування).
- HAS-A описує **внутрішню структуру** об’єкта (складність через включення).
- Обидва принципи важливі для **моделювання об'єктів у реальному світі** в рамках ООП.

---

## У чому різниця між композицією та агрегацією?

### Композиція

**Композиція** — це тип асоціації «частина-цілого», при якому життєвий цикл частини повністю залежить від життєвого циклу цілого. Якщо знищується об’єкт-ціле, то разом з ним знищується і його частина.

Композиція реалізується як сильна залежність між об’єктами: частина **не може існувати самостійно** без цілого.

#### Приклад:
```java
class Page {}

class Book {
    private List<Page> pages = new ArrayList<>();
}
```
У цьому прикладі:
- `Book` **має** `Page`
- Сторінки існують лише в межах книги — **композиція**

### Агрегація

**Агрегація** — це також зв’язок «частина-цілого», але слабший. Частини можуть існувати незалежно від цілого. Це означає, що об’єкти-частини **можуть бути спільно використані** іншими об’єктами або існувати самостійно.

Агрегація відображає ситуацію, коли об'єкт має інший об'єкт, але **не володіє ним повністю**.

#### Приклад:
```java
class Book {}

class Library {
    private List<Book> books; // агрегація
}
```
У цьому прикладі:
- `Library` містить `Book`
- Але книга може існувати й без бібліотеки — **агрегація**

### Порівняння

| Ознака                         | Композиція                          | Агрегація                            |
|--------------------------------|-------------------------------------|--------------------------------------|
| Тип зв’язку                    | Сильна залежність                   | Слабка залежність                    |
| Життєвий цикл частини          | Залежний від цілого                 | Незалежний                          |
| Власність                      | Ціле володіє частинами              | Ціле посилається на частини         |
| Спільне використання об’єкта   | Неможливе                           | Можливе                             |

### Висновок

- Використовуйте **композицію**, коли частина не має сенсу без цілого.
- Використовуйте **агрегацію**, коли частини мають власне життя і можуть бути спільно використані іншими об’єктами.

---

## Чому композиція вважається кращою за успадкування?

### Гнучкість та слабке зв’язування

Композиція дозволяє створювати об’єкти, які **мають поведінку**, делегуючи її іншим об’єктам. Це означає, що об’єкти пов’язані між собою **слабше**, ніж при наслідуванні. Це робить систему більш гнучкою — компоненти можна замінювати або змінювати без впливу на всю ієрархію.

### Повторне використання

Завдяки композиції можна **повторно використовувати** вже існуючі класи без створення глибоких ієрархій. Один і той самий об’єкт може бути включений у різні класи як частина їхньої поведінки.

### Уникнення проблем з наслідуванням

Наслідування часто призводить до:
- **жорсткої зв’язності** між класами;
- **надмірної ієрархії**, яку складно підтримувати;
- **успадкування небажаної поведінки**.

Композиція ж дозволяє **вибірково включати лише необхідну функціональність**.

### Підтримка принципів SOLID

Принцип **композиції** добре узгоджується з принципами SOLID:
- Принцип відкритості/закритості (Open/Closed Principle): легко розширити функціональність, не змінюючи наявний код.
- Принцип заміщення Барбари Лісков (Liskov Substitution Principle): не виникає порушень, як при неправильному наслідуванні.
- Принцип єдиної відповідальності (Single Responsibility Principle): кожен об’єкт відповідає лише за одну роль.

### Приклад

```java
class Engine {
    public void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine = new Engine(); // композиція

    public void start() {
        engine.start(); // делегування
    }
}
```

`Car` не наслідує `Engine`, але **має** його (HAS-A) і делегує йому відповідальність за запуск.

### Висновок

Композиція вважається кращою за успадкування, оскільки:
- забезпечує більшу гнучкість,
- дозволяє уникати надмірної ієрархії,
- сприяє слабкому зв’язуванню та повторному використанню коду,
- краще підтримує принципи чистого об’єктно-орієнтованого дизайну.

---

## Що таке «Liskov Substitution Principle» (Принцип підстановки Лісков)?

### Визначення

**Принцип підстановки Барбари Лісков (Liskov Substitution Principle, LSP)** — це третій принцип із набору SOLID-принципів об'єктно-орієнтованого програмування. Він стверджує:

> Якщо `S` — підклас `T`, то об’єкти типу `T` можуть бути замінені об’єктами типу `S` **без порушення коректності програми**.

Інакше кажучи, **підклас повинен поводитись так, щоб код, який працює з базовим класом, працював і з його нащадками без змін**.

### Приклад порушення LSP

```java
class Bird {
    public void fly() {
        System.out.println("Птах летить");
    }
}

class Ostrich extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Страус не літає!");
    }
}
```

Тут `Ostrich` є `Bird`, але його метод `fly()` порушує очікування базового класу. Якщо в коді хтось викличе `bird.fly()` і підставить страуса — програма зламається.

### Як виправити

Потрібно **переробити ієрархію** так, щоб методи базового класу були дійсними для всіх його підкласів:

```java
class Bird {}

class FlyingBird extends Bird {
    public void fly() {
        System.out.println("Птах летить");
    }
}

class Ostrich extends Bird {
    // не наслідує fly()
}

class Sparrow extends FlyingBird {
    // успадковує fly()
}
```

### Переваги дотримання LSP

- Код стає більш **розширюваним і стабільним**.
- Зменшується кількість **неочікуваних помилок** при використанні підкласів.
- Легше **тестувати** і підтримувати систему.

### Висновок

Принцип Лісков допомагає будувати **правильні ієрархії наслідування**, де підкласи не порушують очікувану поведінку базових класів. Якщо підклас не може повноцінно "бути" батьківським класом, варто переглянути архітектуру або використати композицію.

---

## Як реалізується інтерфейсний поліморфізм у Java?

### Визначення

**Інтерфейсний поліморфізм** — це здатність працювати з об’єктами різних класів через спільний інтерфейс. У Java це реалізується за допомогою **інтерфейсів** (`interface`), які визначають контракт (набір методів), що мають реалізувати класи.

Цей тип поліморфізму дозволяє використовувати один і той самий інтерфейс для виклику методів об’єктів різних типів, які реалізують цей інтерфейс.

### Як це працює

У Java поліморфізм через інтерфейс реалізується динамічно — під час виконання JVM визначає, яку саме реалізацію методу викликати, виходячи з фактичного типу об'єкта.

### Приклад

```java
interface Drawable {
    void draw();
}

class Circle implements Drawable {
    public void draw() {
        System.out.println("Малюю коло");
    }
}

class Rectangle implements Drawable {
    public void draw() {
        System.out.println("Малюю прямокутник");
    }
}

public class Main {
    public static void main(String[] args) {
        Drawable d1 = new Circle();
        Drawable d2 = new Rectangle();

        d1.draw(); // Малюю коло
        d2.draw(); // Малюю прямокутник
    }
}
```

### Пояснення

- `Drawable` — це інтерфейс.
- `Circle` і `Rectangle` реалізують інтерфейс `Drawable`.
- Змінні `d1` і `d2` мають тип `Drawable`, але посилаються на різні об’єкти.
- Метод `draw()` викликається динамічно відповідно до фактичного типу об’єкта — це і є **інтерфейсний поліморфізм**.

### Переваги

- Забезпечує **гнучкість** і **розширюваність** коду.
- Дає змогу **розробляти системи з відкритим API**, де нові класи можна легко додавати без змін до існуючого коду.
- Сприяє **інверсії залежностей** (Dependency Inversion) та **впровадженню залежностей** (Dependency Injection).

### Висновок

Інтерфейсний поліморфізм є основою об’єктно-орієнтованого дизайну в Java. Він дозволяє писати код, орієнтований не на конкретні класи, а на абстракції (інтерфейси), що полегшує тестування, підтримку та масштабування програм.

---

## Що таке шаблонний метод (template method pattern) і як він пов’язаний з ООП?

### Визначення

**Шаблонний метод (Template Method Pattern)** — це поведінковий шаблон проєктування, який визначає каркас алгоритму в методі базового класу, дозволяючи підкласам перевизначати окремі кроки цього алгоритму, не змінюючи його структуру.

Інакше кажучи, базовий клас задає "шаблон" дій, а підкласи можуть змінювати або доповнювати конкретні частини цього шаблону.

### Зв’язок з ООП

Шаблонний метод реалізує ключові принципи ООП:
- **Наслідування** — підкласи успадковують шаблон і можуть перевизначати його частини.
- **Поліморфізм** — вибір реалізації залежить від типу об'єкта під час виконання.
- **Інкапсуляція** — спільна частина алгоритму захована в базовому класі.

### Приклад

```java
abstract class DataProcessor {
    // шаблонний метод
    public final void process() {
        readData();
        processData();
        saveData();
    }

    protected abstract void readData();
    protected abstract void processData();
    protected void saveData() {
        System.out.println("Дані збережено у базу");
    }
}

class CSVDataProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("Читаю CSV-файл");
    }

    @Override
    protected void processData() {
        System.out.println("Обробляю CSV-дані");
    }
}

class JSONDataProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("Читаю JSON-файл");
    }

    @Override
    protected void processData() {
        System.out.println("Обробляю JSON-дані");
    }
}
```

### Використання

```java
DataProcessor processor = new CSVDataProcessor();
processor.process();
// Виведе:
// Читаю CSV-файл
// Обробляю CSV-дані
// Дані збережено у базу
```

### Переваги

- **Повторне використання коду** — спільна логіка зосереджена в одному місці.
- **Гнучкість** — зміна окремих частин без впливу на всю структуру.
- **Зменшення дублювання** — базова поведінка не повторюється у кожному підкласі.

### Висновок

Шаблонний метод — це ефективний спосіб організації алгоритмів із частково змінюваними кроками. Він сприяє повторному використанню коду та відповідає принципу відкритості/закритості (Open/Closed Principle) — дозволяє розширювати поведінку без зміни існуючого коду.

---

## Як реалізується інкапсуляція на рівні модуля або пакету?

### Визначення

Інкапсуляція на рівні модуля або пакету — це обмеження доступу до класів, методів та змінних між різними частинами програми за межами одного пакету чи модуля. Це дозволяє приховати реалізаційні деталі та відкривати лише ті частини, які призначені для зовнішнього використання.

### Інкапсуляція в межах пакету (package-level)

У Java інкапсуляція на рівні пакету реалізується за допомогою **рівня доступу без модифікатора (package-private)** — коли член класу або сам клас не позначений як `public`, `protected` чи `private`. У такому випадку він доступний лише **всередині одного пакету**.

```java
// доступний лише в межах пакету
class InternalHelper {
    void help() {
        System.out.println("Виконую допоміжну дію");
    }
}
```

Це дозволяє розробнику приховати службові класи, які не мають сенсу за межами пакету.

### Інкапсуляція на рівні модуля (Java 9+)

З появою **модулів у Java 9** інкапсуляція розширилась на рівень модулів. Модуль описується у файлі `module-info.java`, в якому вказано, які пакети можуть бути доступні ззовні:

```java
module com.example.myapp {
    exports com.example.api; // доступні зовнішнім модулям
    // інші пакети приховані
}
```

Пакети, які **не вказані в `exports`**, залишаються **інкапсульованими всередині модуля**.

### Переваги

- Покращення **безпеки** коду.
- Зменшення **зв’язності** між модулями.
- Чіткий **розподіл відповідальності** між API та реалізацією.
- Підвищення **зрозумілості** та **супровідності** коду.

### Висновок

Інкапсуляція на рівні модуля або пакету — це важливий інструмент архітектури програм, який дозволяє обмежити область видимості реалізації, залишаючи відкритим лише те, що потрібно зовнішньому світу. Вона підсилює загальну інкапсуляцію, яка є фундаментальним принципом ООП.

---

## Як працює механізм віртуальних методів (virtual methods)?

### Визначення

**Віртуальні методи** — це методи, які можуть бути **перевизначені** у підкласах і викликаються на основі **фактичного типу об'єкта** під час виконання, а не на основі типу змінної. У Java всі нестатичні методи за замовчуванням є віртуальними (окрім `private`, `static`, `final`).

### Як це працює

Коли викликається метод на об'єкті, Java визначає, яку саме реалізацію викликати, на основі **реального типу об'єкта**. Це називається **динамічним (пізнім) зв’язуванням** або **dynamic dispatch**.

### Приклад

```java
class Animal {
    void speak() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.speak(); // Виведе: Dog barks
    }
}
```

Навіть якщо змінна `a` має тип `Animal`, фактичний об'єкт є `Dog`, тому викликається метод `speak()` класу `Dog`.

### Механізм під капотом

При компіляції створюється **таблиця віртуальних методів** (vtable), яка вказує, яку реалізацію методу потрібно викликати. Під час виконання JVM динамічно обирає відповідну реалізацію, переглядаючи vtable відповідного класу.

### Переваги

- Дозволяє реалізовувати **поліморфізм**.
- Спрощує розширення поведінки об'єктів без зміни базового коду.
- Дає змогу писати узагальнені алгоритми, які працюють з базовими типами, але фактично викликають методи підкласів.

### Висновок

Віртуальні методи — один з ключових механізмів ООП, що забезпечує динамічну поведінку програм. Завдяки їм, об'єкти можуть поводитися по-різному залежно від конкретного класу, навіть якщо виклик відбувається через посилання на базовий тип.

---

## Які типові помилки при використанні ООП?

### Надмірне використання наслідування

Зловживання наслідуванням призводить до жорсткої зв’язності між класами, ускладнює підтримку коду та порушує принципи SOLID (зокрема, принцип заміщення Лісков і принцип відкритості/закритості).

### Ігнорування інкапсуляції

Відкриття всіх полів класу як `public` замість використання `private`/`protected` з геттерами та сеттерами порушує інкапсуляцію і призводить до неочікуваних побічних ефектів при зміні стану об'єкта.

### Антипатерн “Бог-об'єкт” (God Object)

Клас, який знає і робить надто багато, порушує принцип єдиної відповідальності. Це призводить до складності в тестуванні, масштабуванні та повторному використанні коду.

### Занадто глибока ієрархія класів

Глибокі дерева наслідування ускладнюють розуміння структури програми та відстеження поведінки методів (особливо якщо вони перевизначаються на кількох рівнях).

### Неправильне використання поліморфізму

Поліморфізм втрачає сенс, якщо замість виклику спільного інтерфейсу використовуються `instanceof` або касти типів для визначення типу об’єкта вручну. Це суперечить ідеї динамічного зв’язування.

### Порушення принципу відкритості/закритості

Замість того, щоб розширювати функціональність через наслідування або делегування, програмісти змінюють існуючий код, що підвищує ризик виникнення помилок і порушує стабільність системи.

### Відсутність або надмірне використання абстракції

- Відсутність абстракції призводить до дублювання коду і зниження повторного використання.
- Надмірна абстракція ускладнює розуміння коду та створює зайву складність.

### Використання об'єктів лише як структур даних

Коли класи використовуються лише для зберігання даних без поведінки (без методів), це більше схоже на процедурний підхід і не використовує переваг ООП.

### Ігнорування тестування об'єктів

Без модульних тестів об'єкти можуть мати приховані помилки в поведінці, які важко виявити під час інтеграції або змін в коді.

### Надмірна залежність між класами

Жорстке з’єднання класів без використання інтерфейсів або шаблонів (як-от dependency injection) робить систему менш гнучкою та важкою для модифікації або повторного використання.

### Висновок

Правильне застосування принципів ООП вимагає обережності, розуміння архітектури системи та дотримання балансів між простотою, гнучкістю та масштабованістю.

---

## Що таке множинне наслідування? Чому Java його не підтримує для класів?

### Визначення

**Множинне наслідування** — це можливість класу успадковувати властивості та поведінку **від кількох батьківських класів одночасно**. Наприклад, клас `C` може наслідувати і `A`, і `B`.

### Чому Java не підтримує множинне наслідування для класів

Java **не дозволяє множинне наслідування класів**, щоб уникнути проблем, пов'язаних із так званою **"проблемою ромба"**.

Уявімо ситуацію:

```java
class A {
    void sayHello() {
        System.out.println("Hello from A");
    }
}

class B extends A {
    @Override
    void sayHello() {
        System.out.println("Hello from B");
    }
}

class C extends A {
    @Override
    void sayHello() {
        System.out.println("Hello from C");
    }
}

// class D extends B, C { } // Не дозволено в Java
```

У цьому випадку, якщо клас `D` наслідував би і `B`, і `C`, компілятору було б незрозуміло, яку саме реалізацію `sayHello()` викликати — з `B` чи з `C`.

### Як Java вирішує цю проблему

Java дозволяє:

- **Один прямий батьківський клас** (`extends` — тільки один).
- **Множинну реалізацію інтерфейсів** (`implements` — скільки завгодно).

Інтерфейси не мають стану і (до Java 8) не мали реалізації методів, тому конфлікти не виникали. Починаючи з Java 8, інтерфейси можуть мати **default-методи**, але Java має чіткі правила для розв’язання конфліктів між ними (через перевизначення або `super` з іменем інтерфейсу).

### Переваги такого підходу

- Уникнення конфліктів методів та полів.
- Простота підтримки та розуміння ієрархії.
- Сприяє **композиції** як альтернативі множинному наслідуванню.

### Висновок

Java відмовилась від множинного наслідування класів на користь **комбінації одиночного наслідування + інтерфейсів**, щоб забезпечити **простоту, ясність і безконфліктну поведінку** об'єктно-орієнтованої моделі.

---

## Як Java дозволяє реалізувати подібність до множинного наслідування?

### Інтерфейси

Java дозволяє реалізувати подібність до множинного наслідування за допомогою **інтерфейсів**. Клас може **реалізовувати кілька інтерфейсів** через ключове слово `implements`. Це дає змогу об'єднати функціональність з різних джерел без конфлікту спадкування.

```java
interface Printable {
    void print();
}

interface Scannable {
    void scan();
}

class MultifunctionPrinter implements Printable, Scannable {
    public void print() {
        System.out.println("Друкую документ");
    }

    public void scan() {
        System.out.println("Сканую документ");
    }
}
```

У прикладі вище клас `MultifunctionPrinter` реалізує два незалежні інтерфейси.

### Default-методи в інтерфейсах (з Java 8)

Java 8 додала можливість створювати **default-методи** в інтерфейсах — це методи з реалізацією. Це дозволяє інтерфейсам мати поведінку без потреби в абстрактному класі.

```java
interface A {
    default void sayHello() {
        System.out.println("Hello from A");
    }
}

interface B {
    default void sayHello() {
        System.out.println("Hello from B");
    }
}

class C implements A, B {
    @Override
    public void sayHello() {
        A.super.sayHello(); // Явне вказання, яку реалізацію використовувати
    }
}
```

### Композиція

Іще один спосіб досягти ефекту множинного наслідування — **композиція**: включити об’єкти інших класів як поля і делегувати їм частину функціональності.

```java
class Engine {
    void start() {
        System.out.println("Двигун запущено");
    }
}

class Car {
    private Engine engine = new Engine();

    void startCar() {
        engine.start();
    }
}
```

### Висновок

Хоча Java не підтримує множинне наслідування класів напряму, вона дозволяє досягти аналогічної гнучкості через:
- реалізацію кількох інтерфейсів;
- використання `default`-методів;
- композицію об'єктів.

---

## У яких випадках краще використовувати абстрактний клас, а в яких — інтерфейс?

### Коли краще використовувати абстрактний клас

- **Є спільна реалізація**: якщо декілька підкласів мають спільну поведінку (реалізацію методів), яку потрібно повторно використати.
- **Потрібен стан (поля)**: абстрактний клас може мати поля, які зберігають загальний стан.
- **Потрібен конструктор**: абстрактні класи можуть мати конструктори, які будуть викликатися підкласами.
- **Має бути частина ієрархії**: коли класи логічно входять в одну ієрархію, наприклад `Animal`, `Dog`, `Cat`.

```java
abstract class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    abstract void makeSound();

    void sleep() {
        System.out.println(name + " спить");
    }
}
```

### Коли краще використовувати інтерфейс

- **Потрібна лише сигнатура поведінки**: інтерфейс визначає, які методи має реалізувати клас, без їхньої реалізації.
- **Потрібна множинна реалізація**: клас може реалізовувати кілька інтерфейсів, що дозволяє комбінувати різну поведінку.
- **Для ролей та можливостей**: наприклад, інтерфейси `Serializable`, `Comparable`, `Runnable` визначають здатності об'єкта, а не його сутність.
- **Для декомпозиції логіки**: часто використовують інтерфейси, щоб розбити систему на чітко визначені контракти.

```java
interface Flyable {
    void fly();
}

class Bird implements Flyable {
    public void fly() {
        System.out.println("Птах летить");
    }
}
```

### Загальні рекомендації

- Якщо потрібна **спадкова поведінка + часткова реалізація** — використовуйте **абстрактний клас**.
- Якщо потрібна **контрактна поведінка** або **множинне "успадкування"**, — краще **інтерфейс**.
- З Java 8 і вище, інтерфейси стали більш потужними завдяки `default`-методам, тому багато випадків можна реалізувати без абстрактного класу.

---

## Опишіть приклад, де доцільно застосувати композицію замість успадкування.

### Приклад застосування композиції замість успадкування

Уявімо, що ми створюємо застосунок для графічного редактора. У нас є класи `Rectangle`, `Circle`, `Triangle`, які всі є різними видами фігур.

Неправильне рішення — зробити клас `DrawingTool` підкласом `Rectangle`, якщо він повинен вміти малювати прямокутник:

```java
class Rectangle {
    void draw() {
        System.out.println("Малюю прямокутник");
    }
}

class DrawingTool extends Rectangle {
    // Поганий підхід, бо DrawingTool — не є прямокутником
}
```

У цьому випадку **успадкування порушує логіку "is-a" (є)**, бо `DrawingTool` — не прямокутник, він лише використовує його.

Правильне рішення — **використати композицію**, щоб об'єкт `DrawingTool` мав у собі фігуру:

```java
interface Shape {
    void draw();
}

class Rectangle implements Shape {
    public void draw() {
        System.out.println("Малюю прямокутник");
    }
}

class DrawingTool {
    private Shape shape;

    public DrawingTool(Shape shape) {
        this.shape = shape;
    }

    public void render() {
        shape.draw();
    }
}
```

Тепер `DrawingTool` **"має" (has-a) фігуру**, замість того щоб бути фігурою. Це дозволяє змінювати поведінку в рантаймі, підвищує гнучкість і не порушує принципів об'єктної моделі.

```java
Shape rect = new Rectangle();
DrawingTool tool = new DrawingTool(rect);
tool.render(); // Виведе: Малюю прямокутник
```

Композиція тут є кращим вибором, оскільки забезпечує слабке зв’язування, можливість гнучкої заміни компонентів та кращу відповідність принципу "має", а не "є".

---

## Як за допомогою ООП реалізувати систему розрахунку заробітної плати для працівників різних типів?

### Приклад ООП-системи розрахунку заробітної плати

Для реалізації системи розрахунку заробітної плати можна використати **абстракцію**, **успадкування** та **поліморфізм**.

Спершу створимо **абстрактний клас `Employee`**, який містить спільну логіку для всіх працівників:

```java
abstract class Employee {
    private String name;

    public Employee(String name) {
        this.name = name;
    }

    public abstract double calculateSalary();

    public String getName() {
        return name;
    }
}
```

Далі реалізуємо різні типи працівників як **підкласи**, що реалізують власну логіку розрахунку:

#### Фіксована місячна зарплата

```java
class SalariedEmployee extends Employee {
    private double monthlySalary;

    public SalariedEmployee(String name, double monthlySalary) {
        super(name);
        this.monthlySalary = monthlySalary;
    }

    @Override
    public double calculateSalary() {
        return monthlySalary;
    }
}
```

#### Оплата за годину

```java
class HourlyEmployee extends Employee {
    private double hourlyRate;
    private int hoursWorked;

    public HourlyEmployee(String name, double hourlyRate, int hoursWorked) {
        super(name);
        this.hourlyRate = hourlyRate;
        this.hoursWorked = hoursWorked;
    }

    @Override
    public double calculateSalary() {
        return hourlyRate * hoursWorked;
    }
}
```

#### Працівник з бонусами

```java
class CommissionEmployee extends Employee {
    private double baseSalary;
    private double commission;

    public CommissionEmployee(String name, double baseSalary, double commission) {
        super(name);
        this.baseSalary = baseSalary;
        this.commission = commission;
    }

    @Override
    public double calculateSalary() {
        return baseSalary + commission;
    }
}
```

### Використання

```java
public class PayrollSystem {
    public static void main(String[] args) {
        Employee[] employees = new Employee[] {
            new SalariedEmployee("Олена", 50000),
            new HourlyEmployee("Іван", 300, 160),
            new CommissionEmployee("Анна", 25000, 10000)
        };

        for (Employee emp : employees) {
            System.out.println(emp.getName() + ": " + emp.calculateSalary());
        }
    }
}
```

### Переваги ООП у цьому прикладі:

- **Поліморфізм** дозволяє викликати метод `calculateSalary()` без знання конкретного типу працівника.
- **Абстракція** приховує внутрішні деталі розрахунку.
- **Наслідування** дозволяє уникнути дублювання коду.
- Легко **додавати нові типи працівників** без зміни існуючої логіки.

---

## Чи можна реалізувати інкапсуляцію без використання модифікаторів доступу?

### Чи можлива інкапсуляція без модифікаторів доступу?

Формально, **реалізувати інкапсуляцію без модифікаторів доступу можливо**, однак така реалізація буде неповною або менш захищеною.

Модифікатори доступу (`private`, `protected`, `public`, `default`) у Java надають **засоби контролю над доступом** до полів та методів класу. Саме завдяки їм можна приховати внутрішню реалізацію та надати доступ лише до необхідного функціоналу.

Без використання модифікаторів:

- **Поля й методи будуть доступні на рівні пакету** (package-private за замовчуванням), що обмежує інкапсуляцію лише межами пакету.
- **Немає захисту від випадкового або неконтрольованого доступу** з інших класів у тому ж пакеті.
- **Контракт використання класу не буде чітко визначеним**, що зменшує надійність та безпечність коду.

Отже, хоч **теоретично інкапсуляцію можна реалізувати через домовленості (наприклад, не використовувати певні поля безпосередньо)**, **на практиці модифікатори доступу є критично важливими** для реалізації повноцінної інкапсуляції у ООП.

### Альтернативні механізми

У деяких інших мовах (наприклад, Python), де немає явних модифікаторів доступу, інкапсуляція реалізується за допомогою **домовленостей (наприклад, префікс `_` чи `__` для "приватних" полів)**. Але навіть там це лише конвенція, а не справжній механізм захисту.

У Java ж модифікатори — це **формальний, контрольований і надійний спосіб забезпечити інкапсуляцію**.

---

## Як виглядає UML-діаграма класів для прикладу з успадкуванням і композицією?

### UML-діаграма класів для прикладу з успадкуванням

Розглянемо приклад:

```java
abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}
```

UML-діаграма виглядатиме так:

```
          +-----------------+
          |    Animal       |<<abstract>>
          +-----------------+
          | +makeSound()    |
          +-----------------+
              ^         ^
              |         |
+-------------+     +-------------+
|    Dog      |     |    Cat      |
+-------------+     +-------------+
| +makeSound()|     | +makeSound()|
+-------------+     +-------------+
```

- Стрілка з порожнім трикутником означає **успадкування**.
- Позначення `<<abstract>>` вказує на абстрактний клас.

---

### UML-діаграма класів для прикладу з композицією

```java
class Engine {
    void start() {
        System.out.println("Engine started");
    }
}

class Car {
    private Engine engine = new Engine();

    void startCar() {
        engine.start();
    }
}
```

UML-діаграма:

```
+------------+       +---------+
|   Car      |<>-----| Engine  |
+------------+       +---------+
| -engine    |       |         |
| +startCar()|       | +start()|
+------------+       +---------+
```

- Ромбик `<>` на боці класу `Car` вказує на **композицію**.
- Це означає, що `Car` **володіє** об'єктом `Engine`, і життєвий цикл `Engine` залежить від `Car`.

---

### Пояснення

- **Успадкування** (наслідування): відносини типу "є" (IS-A). `Dog` і `Cat` є `Animal`.
- **Композиція**: відносини типу "має" (HAS-A). `Car` має `Engine`, і без нього не існує повноцінно.

Ці UML-діаграми допомагають візуально зрозуміти структуру об’єктів та зв’язки між ними.

---

## Чи є можливість створити повністю незмінний об'єкт (Immutable)? Як це вписується в ООП?

### Що таке незмінний об'єкт

Незмінний (immutable) об'єкт — це об'єкт, стан якого не може бути змінено після його створення. Усі його поля є постійними (final), і жоден метод не дозволяє змінити його внутрішні дані.

### Як створити незмінний об'єкт у Java

Щоб створити незмінний клас в Java, необхідно:

1. Зробити клас `final`, щоб його не можна було успадкувати.
2. Зробити всі поля `private` та `final`.
3. Ініціалізувати всі поля в конструкторі.
4. Не надавати сеттерів (setter'ів).
5. Якщо клас містить змінні посилального типу, слід повертати копію об'єкта, а не сам об'єкт (глибока копія).

### Приклад

```java
public final class Person {
    private final String name;
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}
```

У цьому прикладі клас `Person` є повністю незмінним.

### Як це вписується в ООП

Незмінність є частиною принципу інкапсуляції. Вона:

- підвищує безпечність багатопотокових додатків (thread-safety),
- полегшує налагодження, оскільки об'єкти не змінюють стану,
- сприяє функціональному стилю програмування в межах ООП,
- дозволяє створювати стабільні API.

У Java багато стандартних класів (наприклад, `String`, `Integer`, `LocalDate`) є незмінними.

### Висновок

Так, у Java можливо створити повністю незмінний об'єкт. Це підтримується мовою та узгоджується з принципами ООП — насамперед з інкапсуляцією, оскільки обмежує доступ до внутрішнього стану об'єкта.

---
