[Питання на співбесіду](README.md)

# ООП
# Базові питання з ООП
+ [Що таке _об’єктно-орієнтоване програмування (ООП)_?](#що-таке-обєктно-орієнтоване-програмування-ооп)
+ [Які основні принципи _ООП_?](#які-основні-принципи-ооп)
+ [Що таке _інкапсуляція_?](#що-таке-інкапсуляція)
+ [Що таке _наслідування_?](#що-таке-наслідування)
+ [Що таке _поліморфізм_?](#що-таке-поліморфізм)
+ [Що таке _абстракція_?](#що-таке-абстракція)
+ [Що таке _обмін повідомленнями_ в ООП?](#що-таке-обмін-повідомленнями-в-ооп)
+ [У чому різниця між _класом_ і _об’єктом_?](#у-чому-різниця-між-класом-і-обєктом)
+ [Що таке _інтерфейс_ і як він використовується в ООП?](#що-таке-інтерфейс-і-як-він-використовується-в-ооп)
+ [Що означає _реалізує інтерфейс_ (implements interface)?](#що-означає-реалізує-інтерфейс-implements-interface)
+ [Що означає _успадковує клас_ (extends class)?](#що-означає-успадковує-клас-extends-class)
+ [Що таке _конструктор_? Які бувають типи конструкторів?](#що-таке-конструктор-які-бувають-типи-конструкторів)

# Проміжні питання з ООП
+ [У чому полягають _переваги та недоліки ООП_?](#у-чому-полягають-переваги-та-недоліки-ооп)
+ [Яка роль _модифікаторів доступу_ (private, protected, public) у реалізації інкапсуляції?](#яка-роль-модифікаторів-доступу-private-protected-public-у-реалізації-інкапсуляції)
+ [У чому різниця між _перевантаженням_ (overloading) та _перевизначенням_ (overriding) методів?](#у-чому-різниця-між-перевантаженням-overloading-та-перевизначенням-overriding-методів)
+ [Що таке _dynamic dispatch_ (динамічна диспетчеризація)?](#що-таке-dynamic-dispatch-динамічна-диспетчеризація)
+ [У чому різниця між _абстрактним класом_ та _інтерфейсом_?](#у-чому-різниця-між-абстрактним-класом-та-інтерфейсом)
+ [Чим відрізняється _компіляторне (статичне)_ та _виконуване (динамічне) зв’язування_?](#чим-відрізняється-компіляторне-статичне-та-виконуване-динамічне-звязування)
+ [Що таке _final метод / клас / змінна_ і як це пов’язано з ООП?](#що-таке-final-метод--клас--змінна-і-як-це-повязано-з-ооп)
+ [Яка роль ключового слова _super_?](#яка-роль-ключового-слова-super)
+ [Як працює механізм _пізнього (динамічного) зв'язування_ в Java?](#як-працює-механізм-пізнього-динамічного-звязування-в-java)
+ [Що таке _instanceof_ і як воно пов'язане з поліморфізмом?](#що-таке-instanceof-і-як-воно-повязане-з-поліморфізмом)
+ [Чим відрізняється _shallow copy_ від _deep copy_?](#чим-відрізняється-shallow-copy-від-deep-copy)

# Поглиблені питання з ООП
+ [Що означають принципи _«IS-A» (є)_ та _«HAS-A» (має)_?](#що-означають-принципи-is-a-є-та-has-a-має)
+ [У чому різниця між _композицією_ та _агрегацією_?](#у-чому-різниця-між-композицією-та-агрегацією)
+ [Чому _композиція_ вважається кращою за _успадкування_?](#чому-композиція-вважається-кращою-за-успадкування)
+ [Що таке _«Liskov Substitution Principle»_ (Принцип підстановки Лісков)?](#що-таке-liskov-substitution-principle-принцип-підстановки-лісков)
+ [Як реалізується _інтерфейсний поліморфізм_ у Java?](#як-реалізується-інтерфейсний-поліморфізм-у-java)
+ [Що таке _шаблонний метод_ (template method pattern) і як він пов’язаний з ООП?](#що-таке-шаблонний-метод-template-method-pattern-і-як-він-повязаний-з-ооп)
+ [Як реалізується _інкапсуляція на рівні модуля або пакету_?](#як-реалізується-інкапсуляція-на-рівні-модуля-або-пакету)
+ [Як працює механізм _віртуальних методів_ (virtual methods)?](#як-працює-механізм-віртуальних-методів-virtual-methods)
+ [Які _типові помилки_ при використанні ООП?](#які-типові-помилки-при-використанні-ооп)
+ [Що таке _множинне наслідування_? Чому Java його не підтримує для класів?](#що-таке-множинне-успадкування-чому-java-його-не-підтримує-для-класів)
+ [Як Java дозволяє реалізувати _подібність до множинного наслідування_?](#як-java-дозволяє-реалізувати-подібність-до-множинного-успадкування)

# Прикладні питання та сценарії
+ [У яких випадках краще використовувати _абстрактний клас_, а в яких — _інтерфейс_?](#у-яких-випадках-краще-використовувати-абстрактний-клас-а-в-яких--інтерфейс)
+ [Опишіть приклад, де доцільно застосувати _композицію_ замість _успадкування_.](#опишіть-приклад-де-доцільно-застосувати-композицію-замість-успадкування)
+ [Як за допомогою ООП реалізувати _систему розрахунку заробітної плати_ для працівників різних типів?](#як-за-допомогою-ооп-реалізувати-систему-розрахунку-заробітної-плати-для-працівників-різних-типів)
+ [Чи можна реалізувати _інкапсуляцію без використання модифікаторів доступу_?](#чи-можна-реалізувати-інкапсуляцію-без-використання-модифікаторів-доступу)
+ [Як виглядає _UML-діаграма класів_ для прикладу з наслідуванням і композицією?](#як-виглядає-uml-діаграма-класів-для-прикладу-з-успадкуванням-і-композицією)
+ [Чи є можливість створити _повністю незмінний об'єкт (Immutable)_? Як це вписується в ООП?](#чи-є-можливість-створити-повністю-незмінний-обєкт-immutable-як-це-вписується-в-ооп)

---


## Що таке об’єктно-орієнтоване програмування (ООП)?


**Об’єктно-орієнтоване програмування (ООП)** — це парадигма (методологія) програмування, в основі якої лежить представлення програми у вигляді **сукупності об’єктів**, кожен з яких є **екземпляром певного класу**, а класи утворюють **ієрархію наслідування**.

### Основні принципи ООП:

1. **Інкапсуляція**  
   Приховування внутрішньої реалізації об'єкта від зовнішнього світу. Всі взаємодії відбуваються через публічні методи (інтерфейс).

2. **Наслідування**  
   Можливість створення нового класу на основі вже існуючого. Новий клас успадковує поля та методи батьківського класу.

3. **Поліморфізм**  
   Можливість об’єктів поводитись по-різному при виклику одного й того ж методу (в залежності від фактичного типу об’єкта).

4. **Абстракція**  
   Виділення суттєвих характеристик об’єкта та приховування несуттєвих деталей. Дає змогу працювати з об’єктами на більш високому рівні узагальнення.

### Основні поняття ООП:

- **Клас** — шаблон (опис), за яким створюються об’єкти.
- **Об’єкт** — екземпляр класу.
- **Метод** — функція, яка визначає поведінку об’єкта.
- **Поле (змінна класу)** — характеристика (стан) об’єкта.

> Програма вважається об'єктно-орієнтованою, **тільки якщо дотримано всі три ключові вимоги**:
> - використовуються **об'єкти як основні логічні елементи**, а не алгоритми,
> - кожен об'єкт є **екземпляром класу**,
> - класи утворюють **ієрархію** (тобто підтримується **успадкування**).

> Якщо успадкування не використовується, то це вже **не ООП**, а **програмування з використанням абстрактних типів даних**.

### Приклад (Java):

```java
class Animal {
    String name;

    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    void speak() {
        System.out.println("Dog barks");
    }
}

Animal a = new Dog();
a.speak(); // Виведе: Dog barks (поліморфізм)
```

### Поведінка об’єктів в ООП

Згідно з парадигмою ООП, програма складається з **об’єктів, які обмінюються повідомленнями**.

- Об’єкти можуть **мати стан** (зберігати дані).
- Єдиний спосіб **змінити стан об’єкта** — **послати йому повідомлення** (тобто викликати метод).
- У відповідь на повідомлення об’єкт **може змінити свій стан або виконати дію**.

Цей підхід дозволяє створювати модульні, розширювані й керовані програми.

---

### Які основні принципи ООП?

1. **Інкапсуляція** — приховування реалізації. Об'єкт приховує внутрішні деталі та надає доступ до них тільки через публічні методи.

2. **Наслідування** — створення нової сутності на основі вже існуючої. Дочірній клас наслідує властивості та поведінку батьківського.

3. **Поліморфізм** — можливість мати різні форми для однієї й тієї ж сутності. Один і той самий метод може поводитися по-різному в залежності від контексту.

4. **Абстракція** — набір суттєвих загальних характеристик, що дозволяє працювати з об’єктами на високому рівні узагальнення без деталізації реалізації.

5. **Посилка повідомлень** — форма зв’язку та взаємодії між об’єктами. Об'єкти надсилають одне одному повідомлення (виклики методів) для виконання дій.

6. **Повторне використання (реюз)** — всі попередні принципи забезпечують можливість ефективного повторного використання коду.

> Це єдино правильний порядок принципів ООП, оскільки кожен наступний базується на попередньому.

---


### Що таке інкапсуляція?

**Інкапсуляція** — це властивість об’єктно-орієнтованої системи, яка дозволяє **об’єднати дані (поля) та методи, що з ними працюють, у класі**, і **приховати реалізаційні деталі** від зовнішнього світу. Зовнішнім користувачам відкривається лише те, що необхідне для взаємодії з об’єктом.

#### Мета інкапсуляції:
- **Зменшити залежність** зовнішнього коду від внутрішньої реалізації класу.
- **Захистити** внутрішній стан об’єкта від неправильного використання.
- **Дати змогу змінювати реалізацію без зміни зовнішнього інтерфейсу**.

> Якщо змінюється внутрішня логіка класу, але зовнішній інтерфейс залишається незмінним — інші частини програми не постраждають.

#### Приклад з життя:

Уявіть собі автомобіль 19 століття, що працює на парі. Для його водіння треба:
- постійно слідкувати за рівнем води та температурою,
- підкидати вугілля,
- управляти колесами через окремі важелі.

Сучасна машина працює так само — там є паливна система, двигун, передача моменту, поворот коліс — **але водієві все це не потрібно знати**. Він просто:
- натискає педаль газу,
- крутить кермо.

**Складна реалізація схована**, і це дозволяє використовувати автомобіль навіть тим, хто ніколи не вивчав механіку. **Це і є інкапсуляція** — приховання деталей реалізації та відкриття лише потрібного інтерфейсу.

#### Приклад на Java:

```java
public class AbstractPhone {

    private int year;
    private String company;

    public AbstractPhone(int year, String company) {
        this.year = year;
        this.company = company;
    }

    private void openConnection() {
        // findComutator
        // openNewConnection...
    }

    public void call() {
        openConnection();
        System.out.println("Виклик номера");
    }

    public void ring() {
        System.out.println("Дзень-дзень");
    }
}
```

- Поля `year` та `company`, а також метод `openConnection()` — **закриті** (`private`). Це означає, що вони **недоступні зовні**.
- Метод `call()` **публічний** (`public`) і надає **контрольований доступ** до функціональності телефону.
- **Внутрішню логіку** методу `openConnection()` можна змінити, не побоюючись, що це зламає інші частини програми.

#### Висновок:

Інкапсуляція:
- приховує складність,
- захищає об’єкт,
- дозволяє змінювати реалізацію без ризику для інших компонентів,
- забезпечує чіткий і безпечний інтерфейс для взаємодії з об'єктом.

Це **один із ключових принципів ООП**, без якого неможливо створити надійну та гнучку систему.

---


### Що таке наслідування?

### Що таке поліморфізм?

### Що таке абстракція?

### Що таке обмін повідомленнями в ООП?

### У чому різниця між класом і об’єктом?

### Що таке інтерфейс і як він використовується в ООП?

### Що означає реалізує інтерфейс (implements interface)?

### Що означає успадковує клас (extends class)?

### Що таке конструктор? Які бувають типи конструкторів?








### У чому полягають переваги та недоліки ООП?

### Яка роль модифікаторів доступу (private, protected, public) у реалізації інкапсуляції?

### У чому різниця між перевантаженням (overloading) та перевизначенням (overriding) методів?

### Що таке dynamic dispatch (динамічна диспетчеризація)?

### У чому різниця між абстрактним класом та інтерфейсом?

### Чим відрізняється компіляторне (статичне) та виконуване (динамічне) зв’язування?

### Що таке final метод / клас / змінна і як це пов’язано з ООП?

### Яка роль ключового слова super?

### Як працює механізм пізнього (динамічного) зв'язування в Java?

### Що таке instanceof і як воно пов'язане з поліморфізмом?

### Чим відрізняється shallow copy від deep copy?








### Що означають принципи «IS-A» (є) та «HAS-A» (має)?

### У чому різниця між композицією та агрегацією?

### Чому композиція вважається кращою за успадкування?

### Що таке «Liskov Substitution Principle» (Принцип підстановки Лісков)?

### Як реалізується інтерфейсний поліморфізм у Java?

### Що таке шаблонний метод (template method pattern) і як він пов’язаний з ООП?

### Як реалізується інкапсуляція на рівні модуля або пакету?

### Як працює механізм віртуальних методів (virtual methods)?

### Які типові помилки при використанні ООП?

### Що таке множинне наслідування? Чому Java його не підтримує для класів?

### Як Java дозволяє реалізувати подібність до множинного наслідування?








### У яких випадках краще використовувати абстрактний клас, а в яких — інтерфейс?

### Опишіть приклад, де доцільно застосувати композицію замість успадкування.

### Як за допомогою ООП реалізувати систему розрахунку заробітної плати для працівників різних типів?

### Чи можна реалізувати інкапсуляцію без використання модифікаторів доступу?

### Як виглядає UML-діаграма класів для прикладу з успадкуванням і композицією?

### Чи є можливість створити повністю незмінний об'єкт (Immutable)? Як це вписується в ООП?
