[Питання на співбесіду](README.md)

# ООП
# Базові питання з ООП
+ [Що таке _об’єктно-орієнтоване програмування (ООП)_?](#що-таке-обєктно-орієнтоване-програмування-ооп)
+ [Які основні принципи _ООП_?](#які-основні-принципи-ооп)
+ [Що таке _інкапсуляція_?](#що-таке-інкапсуляція)
+ [Що таке _наслідування_?](#що-таке-наслідування)
+ [Що таке _поліморфізм_?](#що-таке-поліморфізм)
+ [Що таке _абстракція_?](#що-таке-абстракція)
+ [Що таке _обмін повідомленнями_ в ООП?](#що-таке-обмін-повідомленнями-в-ооп)
+ [У чому різниця між _класом_ і _об’єктом_?](#у-чому-різниця-між-класом-і-обєктом)
+ [Що таке _інтерфейс_ і як він використовується в ООП?](#що-таке-інтерфейс-і-як-він-використовується-в-ооп)
+ [Що означає _реалізує інтерфейс_ (implements interface)?](#що-означає-реалізує-інтерфейс-implements-interface)
+ [Що означає _успадковує клас_ (extends class)?](#що-означає-успадковує-клас-extends-class)
+ [Що таке _конструктор_? Які бувають типи конструкторів?](#що-таке-конструктор-які-бувають-типи-конструкторів)

# Проміжні питання з ООП
+ [У чому полягають _переваги та недоліки ООП_?](#у-чому-полягають-переваги-та-недоліки-ооп)
+ [Яка роль _модифікаторів доступу_ (private, protected, public) у реалізації інкапсуляції?](#яка-роль-модифікаторів-доступу-private-protected-public-у-реалізації-інкапсуляції)
+ [У чому різниця між _перевантаженням_ (overloading) та _перевизначенням_ (overriding) методів?](#у-чому-різниця-між-перевантаженням-overloading-та-перевизначенням-overriding-методів)
+ [Що таке _dynamic dispatch_ (динамічна диспетчеризація)?](#що-таке-dynamic-dispatch-динамічна-диспетчеризація)
+ [У чому різниця між _абстрактним класом_ та _інтерфейсом_?](#у-чому-різниця-між-абстрактним-класом-та-інтерфейсом)
+ [Чим відрізняється _компіляторне (статичне)_ та _виконуване (динамічне) зв’язування_?](#чим-відрізняється-компіляторне-статичне-та-виконуване-динамічне-звязування)
+ [Що таке _final метод / клас / змінна_ і як це пов’язано з ООП?](#що-таке-final-метод--клас--змінна-і-як-це-повязано-з-ооп)
+ [Яка роль ключового слова _super_?](#яка-роль-ключового-слова-super)
+ [Як працює механізм _пізнього (динамічного) зв'язування_ в Java?](#як-працює-механізм-пізнього-динамічного-звязування-в-java)
+ [Що таке _instanceof_ і як воно пов'язане з поліморфізмом?](#що-таке-instanceof-і-як-воно-повязане-з-поліморфізмом)
+ [Чим відрізняється _shallow copy_ від _deep copy_?](#чим-відрізняється-shallow-copy-від-deep-copy)

# Поглиблені питання з ООП
+ [Що означають принципи _«IS-A» (є)_ та _«HAS-A» (має)_?](#що-означають-принципи-is-a-є-та-has-a-має)
+ [У чому різниця між _композицією_ та _агрегацією_?](#у-чому-різниця-між-композицією-та-агрегацією)
+ [Чому _композиція_ вважається кращою за _успадкування_?](#чому-композиція-вважається-кращою-за-успадкування)
+ [Що таке _«Liskov Substitution Principle»_ (Принцип підстановки Лісков)?](#що-таке-liskov-substitution-principle-принцип-підстановки-лісков)
+ [Як реалізується _інтерфейсний поліморфізм_ у Java?](#як-реалізується-інтерфейсний-поліморфізм-у-java)
+ [Що таке _шаблонний метод_ (template method pattern) і як він пов’язаний з ООП?](#що-таке-шаблонний-метод-template-method-pattern-і-як-він-повязаний-з-ооп)
+ [Як реалізується _інкапсуляція на рівні модуля або пакету_?](#як-реалізується-інкапсуляція-на-рівні-модуля-або-пакету)
+ [Як працює механізм _віртуальних методів_ (virtual methods)?](#як-працює-механізм-віртуальних-методів-virtual-methods)
+ [Які _типові помилки_ при використанні ООП?](#які-типові-помилки-при-використанні-ооп)
+ [Що таке _множинне наслідування_? Чому Java його не підтримує для класів?](#що-таке-множинне-успадкування-чому-java-його-не-підтримує-для-класів)
+ [Як Java дозволяє реалізувати _подібність до множинного наслідування_?](#як-java-дозволяє-реалізувати-подібність-до-множинного-успадкування)

# Прикладні питання та сценарії
+ [У яких випадках краще використовувати _абстрактний клас_, а в яких — _інтерфейс_?](#у-яких-випадках-краще-використовувати-абстрактний-клас-а-в-яких--інтерфейс)
+ [Опишіть приклад, де доцільно застосувати _композицію_ замість _успадкування_.](#опишіть-приклад-де-доцільно-застосувати-композицію-замість-успадкування)
+ [Як за допомогою ООП реалізувати _систему розрахунку заробітної плати_ для працівників різних типів?](#як-за-допомогою-ооп-реалізувати-систему-розрахунку-заробітної-плати-для-працівників-різних-типів)
+ [Чи можна реалізувати _інкапсуляцію без використання модифікаторів доступу_?](#чи-можна-реалізувати-інкапсуляцію-без-використання-модифікаторів-доступу)
+ [Як виглядає _UML-діаграма класів_ для прикладу з наслідуванням і композицією?](#як-виглядає-uml-діаграма-класів-для-прикладу-з-успадкуванням-і-композицією)
+ [Чи є можливість створити _повністю незмінний об'єкт (Immutable)_? Як це вписується в ООП?](#чи-є-можливість-створити-повністю-незмінний-обєкт-immutable-як-це-вписується-в-ооп)

---


## Що таке об’єктно-орієнтоване програмування (ООП)?

**Об’єктно-орієнтоване програмування (ООП)** — це парадигма (методологія) програмування, в основі якої лежить представлення програми у вигляді **сукупності об’єктів**, кожен з яких є **екземпляром певного класу**, а класи утворюють **ієрархію наслідування**.

### Основні принципи ООП:

1. **Інкапсуляція**  
   Приховування внутрішньої реалізації об'єкта від зовнішнього світу. Всі взаємодії відбуваються через публічні методи (інтерфейс).

2. **Наслідування**  
   Можливість створення нового класу на основі вже існуючого. Новий клас успадковує поля та методи батьківського класу.

3. **Поліморфізм**  
   Можливість об’єктів поводитись по-різному при виклику одного й того ж методу (в залежності від фактичного типу об’єкта).

4. **Абстракція**  
   Виділення суттєвих характеристик об’єкта та приховування несуттєвих деталей. Дає змогу працювати з об’єктами на більш високому рівні узагальнення.

### Основні поняття ООП:

- **Клас** — шаблон (опис), за яким створюються об’єкти.
- **Об’єкт** — екземпляр класу.
- **Метод** — функція, яка визначає поведінку об’єкта.
- **Поле (змінна класу)** — характеристика (стан) об’єкта.

> Програма вважається об'єктно-орієнтованою, **тільки якщо дотримано всі три ключові вимоги**:
> - використовуються **об'єкти як основні логічні елементи**, а не алгоритми,
> - кожен об'єкт є **екземпляром класу**,
> - класи утворюють **ієрархію** (тобто підтримується **успадкування**).

> Якщо успадкування не використовується, то це вже **не ООП**, а **програмування з використанням абстрактних типів даних**.

### Приклад (Java):

```java
class Animal {
    String name;

    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    void speak() {
        System.out.println("Dog barks");
    }
}

Animal a = new Dog();
a.speak(); // Виведе: Dog barks (поліморфізм)
```

### Поведінка об’єктів в ООП

Згідно з парадигмою ООП, програма складається з **об’єктів, які обмінюються повідомленнями**.

- Об’єкти можуть **мати стан** (зберігати дані).
- Єдиний спосіб **змінити стан об’єкта** — **послати йому повідомлення** (тобто викликати метод).
- У відповідь на повідомлення об’єкт **може змінити свій стан або виконати дію**.

Цей підхід дозволяє створювати модульні, розширювані й керовані програми.


---

## Які основні принципи ООП?

1. **Інкапсуляція** — приховування реалізації. Об'єкт приховує внутрішні деталі та надає доступ до них тільки через публічні методи.

2. **Наслідування** — створення нової сутності на основі вже існуючої. Дочірній клас наслідує властивості та поведінку батьківського.

3. **Поліморфізм** — можливість мати різні форми для однієї й тієї ж сутності. Один і той самий метод може поводитися по-різному в залежності від контексту.

4. **Абстракція** — набір суттєвих загальних характеристик, що дозволяє працювати з об’єктами на високому рівні узагальнення без деталізації реалізації.

5. **Посилка повідомлень** — форма зв’язку та взаємодії між об’єктами. Об'єкти надсилають одне одному повідомлення (виклики методів) для виконання дій.

6. **Повторне використання (реюз)** — всі попередні принципи забезпечують можливість ефективного повторного використання коду.

> Це єдино правильний порядок принципів ООП, оскільки кожен наступний базується на попередньому.

---


## Що таке інкапсуляція?

**Інкапсуляція** — це властивість об’єктно-орієнтованої системи, яка дозволяє **об’єднати дані (поля) та методи, що з ними працюють, у класі**, і **приховати реалізаційні деталі** від зовнішнього світу. Зовнішнім користувачам відкривається лише те, що необхідне для взаємодії з об’єктом.

### Мета інкапсуляції:
- **Зменшити залежність** зовнішнього коду від внутрішньої реалізації класу.
- **Захистити** внутрішній стан об’єкта від неправильного використання.
- **Дати змогу змінювати реалізацію без зміни зовнішнього інтерфейсу**.

> Якщо змінюється внутрішня логіка класу, але зовнішній інтерфейс залишається незмінним — інші частини програми не постраждають.

### Приклад з життя:

Уявіть собі автомобіль 19 століття, що працює на парі. Для його водіння треба:
- постійно слідкувати за рівнем води та температурою,
- підкидати вугілля,
- управляти колесами через окремі важелі.

Сучасна машина працює так само — там є паливна система, двигун, передача моменту, поворот коліс — **але водієві все це не потрібно знати**. Він просто:
- натискає педаль газу,
- крутить кермо.

**Складна реалізація схована**, і це дозволяє використовувати автомобіль навіть тим, хто ніколи не вивчав механіку. **Це і є інкапсуляція** — приховання деталей реалізації та відкриття лише потрібного інтерфейсу.

### Приклад на Java:

```java
public class AbstractPhone {

    private int year;
    private String company;

    public AbstractPhone(int year, String company) {
        this.year = year;
        this.company = company;
    }

    private void openConnection() {
        // findComutator
        // openNewConnection...
    }

    public void call() {
        openConnection();
        System.out.println("Виклик номера");
    }

    public void ring() {
        System.out.println("Дзень-дзень");
    }
}
```

- Поля `year` та `company`, а також метод `openConnection()` — **закриті** (`private`). Це означає, що вони **недоступні зовні**.
- Метод `call()` **публічний** (`public`) і надає **контрольований доступ** до функціональності телефону.
- **Внутрішню логіку** методу `openConnection()` можна змінити, не побоюючись, що це зламає інші частини програми.

### Висновок:

Інкапсуляція:
- приховує складність,
- захищає об’єкт,
- дозволяє змінювати реалізацію без ризику для інших компонентів,
- забезпечує чіткий і безпечний інтерфейс для взаємодії з об'єктом.

Це **один із ключових принципів ООП**, без якого неможливо створити надійну та гнучку систему.

---

## Що таке наслідування?

**Наслідування** — це властивість об’єктно-орієнтованої системи, яка дозволяє **описати новий клас на основі вже існуючого**, **успадковуючи його властивості та поведінку** частково або повністю.

- Клас, від якого відбувається наслідування, називається **батьківським**, **базовим** або **предком**.
- Новий клас, що наслідує, називається **нащадком**, **похідним** або **дочірнім класом**.

### Мета наслідування:
- Повторне використання коду без дублювання.
- Розширення або модифікація вже існуючої функціональності.
- Побудова ієрархії типів (класифікація об’єктів).

### Приклад із життя:

Уявімо, що ми — інженери на автомобільному заводі. Ми маємо успішну стару модель автомобіля, яка добре себе зарекомендувала. Замість того, щоб створювати нову модель з нуля, ми беремо за основу стару конструкцію та:
- додаємо гідропідсилювач керма,
- оновлюємо фари,
- змінюємо форму кузова.

Ми створюємо **нові модифікації** (седан, універсал, хетчбек), які **успадковують більшість характеристик** базової моделі, але також мають свої унікальні риси. Це і є **наслідування** — використання старого як основи для створення нового з мінімальними зусиллями.

### Приклад на Java:

```java
// Базовий клас: бездротовий телефон
public abstract class WirelessPhone extends AbstractPhone {

    private int hour;

    public WirelessPhone(int year, int hour) {
        super(year);
        this.hour = hour;
    }
}
```

```java
// Похідний клас: мобільний телефон
public class CellPhone extends WirelessPhone {
    public CellPhone(int year, int hour) {
        super(year, hour);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Викликаю номер " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Дзвонить абонент " + inputNumber);
    }
}
```

```java
// Похідний клас: смартфон
public class Smartphone extends CellPhone {

    private String operationSystem;

    public Smartphone(int year, int hour, String operationSystem) {
        super(year, hour);
        this.operationSystem = operationSystem;
    }

    public void install(String program) {
        System.out.println("Встановлюю " + program + " для " + operationSystem);
    }
}
```

### Пояснення:

- `Smartphone` наслідує `CellPhone`, який наслідує `WirelessPhone`.
- Ми **розширюємо функціональність**: кожен новий клас додає щось своє (наприклад, операційну систему та метод `install()`).
- Завдяки наслідуванню ми не дублюємо код, а лише додаємо нові можливості.

### Висновок:

Наслідування:
- дозволяє створювати нові класи на базі існуючих,
- сприяє повторному використанню коду,
- забезпечує логічну ієрархію об’єктів,
- зменшує обсяг коду та спрощує його підтримку.

Це один із базових принципів ООП, що дає змогу легко масштабувати програмні рішення.

---


## Що таке поліморфізм?

**Поліморфізм** — це здатність системи використовувати **об’єкти з однаковим інтерфейсом без знання їх точного типу** або внутрішньої структури. Інакше кажучи, програма може взаємодіяти з об'єктами через спільний інтерфейс, а **реальна поведінка визначається під час виконання**.

### Мета поліморфізму:
- **Зменшити складність** системи.
- **Забезпечити гнучкість** коду.
- **Використовувати спільний інтерфейс** для об'єктів різних класів.
- **Замінювати об’єкти базового класу на об’єкти його нащадків**, не змінюючи логіку програми.

### Приклад з життя:

Усі автомобілі мають **один і той самий інтерфейс керування**: кермо, педалі, коробка передач. Людина, яка навчилася водити один тип автомобіля, зможе легко сісти за кермо іншого — **оскільки вона працює з уніфікованим інтерфейсом**, незалежно від внутрішньої реалізації машини.

> Так і в ООП: об'єкти мають спільний інтерфейс (наприклад, метод `call()`), але реалізують його по-своєму.

### Види поліморфізму:

1. **Ad hoc (випадковий)** — метод поводиться по-різному для різних типів:
   > Наприклад, `draw()` малює коло або квадрат по-різному.

2. **Параметричний** — метод працює однаково з аргументами різних типів:
   > Наприклад, `add()` додає в контейнер будь-який об’єкт.
   
### Приклад на Java:

```java
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public void callAnotherUser(int number, AbstractPhone phone) {
        phone.call(number); // Ось він — поліморфізм!
    }
}
```

```java
public class ThomasEdisonPhone extends AbstractPhone {
    public ThomasEdisonPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Крутіть ручку");
        System.out.println("Назвіть номер абонента, сер");
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон дзвонить");
    }
}
```

```java
public class Phone extends AbstractPhone {
    public Phone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Викликаю номер " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("Телефон дзвонить");
    }
}
```

```java
public class VideoPhone extends AbstractPhone {
    public VideoPhone(int year) {
        super(year);
    }

    @Override
    public void call(int outputNumber) {
        System.out.println("Підключаю відеоканал для абонента " + outputNumber);
    }

    @Override
    public void ring(int inputNumber) {
        System.out.println("У вас відеодзвінок від " + inputNumber);
    }
}
```

```java
// Приклад використання
AbstractPhone firstPhone = new ThomasEdisonPhone(1879);
AbstractPhone phone = new Phone(1984);
AbstractPhone videoPhone = new VideoPhone(2018);
User user = new User("Андрій");

user.callAnotherUser(224466, firstPhone);
// Крутіть ручку
// Назвіть номер абонента, сер

user.callAnotherUser(224466, phone);
// Викликаю номер 224466

user.callAnotherUser(224466, videoPhone);
// Підключаю відеоканал для абонента 224466
```

У кожному з трьох викликів використовується **один і той самий метод `callAnotherUser()`**, але результат — різний, бо **реальна реалізація `call()` визначається динамічно**, залежно від типу об’єкта. Це і є **динамічний поліморфізм**.

### Перевизначення методів

Механізм поліморфізму реалізується через **перевизначення методів** — тобто заміну методу базового класу у підкласі з тією ж сигнатурою. У Java для цього використовується анотація `@Override`.

### Висновок:

Поліморфізм:
- дозволяє писати гнучкий, масштабований код;
- дає змогу працювати з об’єктами через загальний інтерфейс;
- забезпечує **реалізацію одного й того ж методу різними способами**;
- базується на **наслідуванні та абстракції**.

Це — один із ключових принципів ООП, що дає змогу створювати зручні та універсальні програмні моделі.

---

## Що таке абстракція?

**Абстракція** — це процес **виділення суттєвих характеристик об'єкта** та **ігнорування несуттєвих або другорядних деталей**. У результаті ми отримуємо **узагальнене уявлення про об'єкт**, яке зручно використовувати у програмі.

### Мета абстракції:
- Спрощення сприйняття складної системи.
- Зосередження уваги на головному, без занурення в технічні деталі.
- Надання загального інтерфейсу для взаємодії з об'єктами різних типів.

### Приклад з життя:

Уявіть водія, який їде автомобілем у міському трафіку. У цей момент він:
- **не думає** про хімічний склад фарби машини,
- **не замислюється** над тим, як працюють шестерні коробки передач,
- **не аналізує** форму кузова.

Він зосереджений лише на **важливих речах**:
- крутить кермо,
- тисне на педалі,
- вмикає поворотники.

> Ці елементи керування — **абстракція** автомобіля. Водієві не потрібно знати, що відбувається "під капотом", щоб керувати.

### Приклад на Java:

```java
// Абстрактний клас
abstract class Animal {
    // Абстрактний метод (без тіла)
    public abstract void animalSound();

    // Звичайний метод
    public void sleep() {
        System.out.println("Zzz");
    }
}

// Підклас, який реалізує абстрактний метод
class Pig extends Animal {
    public void animalSound() {
        System.out.println("Свиня каже: хрю-хрю");
    }
}

class MyMainClass {
    public static void main(String[] args) {
        Pig myPig = new Pig();      // Створюємо об'єкт
        myPig.animalSound();        // Виведе: Свиня каже: хрю-хрю
        myPig.sleep();              // Виведе: Zzz
    }
}
```

### Пояснення:
- Клас `Animal` містить **абстрактний метод `animalSound()`**, який не має тіла.
- Підклас `Pig` **реалізує цей метод**, визначаючи конкретну поведінку.
- Клас `Animal` виступає як **інтерфейс взаємодії**, який приховує реалізацію.
- Завдяки цьому ми можемо створювати нові підкласи (`Cat`, `Dog`, `Cow` тощо), не змінюючи базовий інтерфейс.

### Висновок:

**Абстракція**:
- дозволяє створювати узагальнені інтерфейси,
- приховує складні деталі реалізації,
- забезпечує спрощену модель взаємодії з об'єктами,
- є ключовим принципом для реалізації масштабованих і підтримуваних систем.

> В ООП **абстракція тісно пов'язана з інтерфейсами та абстрактними класами**, які дозволяють описувати, *що саме має робити об'єкт*, а не *як саме він це робить*.

---

## Що таке обмін повідомленнями в ООП?

**Обмін повідомленнями** — це механізм взаємодії об’єктів в об’єктно-орієнтованому програмуванні. Об’єкти спілкуються між собою **через надсилання та отримання повідомлень**, тобто виклики методів.

### Що таке повідомлення?

**Повідомлення** — це запит об’єкту на виконання певної дії (виклик методу), який може містити аргументи, необхідні для виконання цієї дії.

> У термінах програмування повідомлення — це **виклик методу об’єкта** з певними параметрами.

### Як це працює:

- Коли один об’єкт викликає метод іншого — він **надсилає йому повідомлення**.
- Об’єкт, який отримав повідомлення, **реагує на нього**, виконуючи відповідну дію.
- Щоб об’єкт міг "відповісти", у нього має бути **метод з відповідним іменем**.
- Об’єкти також можуть у відповідь **надсилати повідомлення іншим об’єктам**.

### Відмінність від традиційного підходу

У традиційному (процедурному) програмуванні:
- Існує **одна загальна функція**, наприклад, `bounce(ballId)`, яка обробляє дані кулі, передані через індекс або ідентифікатор.

В ООП:
- Кожна куля — це **окремий об’єкт** із власними властивостями та методом `bounce()`.
- Замість передачі ідентифікатора кулі у функцію, ми просто **надсилаємо повідомлення (виклик методу) конкретному об’єкту**:

```java
ball3.bounce();
```

> У такий спосіб кожен об'єкт **сам відповідає за свою поведінку**.

### Приклад:

```java
class Ball {
    private double radius;

    public Ball(double radius) {
        this.radius = radius;
    }

    public void bounce() {
        System.out.println("Куля з радіусом " + radius + " підскочила!");
    }
}

// У головному методі
Ball ball1 = new Ball(5.0);
Ball ball2 = new Ball(10.0);

ball1.bounce(); // Надсилаємо повідомлення об'єкту ball1
ball2.bounce(); // Надсилаємо повідомлення об'єкту ball2
```

### Технічна особливість

У Java виклики методів (тобто обмін повідомленнями) реалізуються через **динамічне зв’язування (late binding)** — це означає, що програма визначає, який саме метод викликати **під час виконання**, а не під час компіляції. Це забезпечує **гнучкість і підтримку поліморфізму**.

### Висновок:

- **Обмін повідомленнями** — це ключовий механізм взаємодії об'єктів в ООП.
- Він дозволяє об'єктам керувати поведінкою один одного через виклики методів.
- Це забезпечує **низьку зв’язаність**, **модульність**, **гнучкість** та **розширюваність** коду.
- На відміну від процедурного стилю, **поведінка об'єкта інкапсулюється всередині самого об’єкта**, що є однією з головних переваг ООП.

---

## У чому різниця між класом і об’єктом?

У об'єктно-орієнтованому програмуванні **клас** і **об’єкт** — це два фундаментальні поняття, які тісно пов’язані між собою, але виконують різні ролі.

### Клас

**Клас** — це **шаблон або креслення**, за яким створюються об’єкти. Він описує:
- які **дані (поля)** матиме об’єкт,
- яку **поведінку (методи)** він може виконувати.

> Клас — це **абстракція**, яка не займає пам’яті до моменту створення об’єкта.

### Об’єкт

**Об’єкт** — це **конкретний екземпляр класу**, який вже існує в пам’яті під час виконання програми.

Об’єкт:
- має **свій стан** (конкретні значення полів),
- може виконувати **методи**, визначені у класі.

### Порівняння:

| Ознака         | Клас                             | Об’єкт                                      |
|----------------|----------------------------------|---------------------------------------------|
| Що це          | Шаблон, опис                     | Реалізація, екземпляр класу                 |
| Існування      | Ідея, не займає пам’яті          | Існує під час виконання, займає пам’ять     |
| Мета           | Описує структуру та поведінку    | Втілює поведінку, працює з даними           |
| Приклад (Java) | `class Car { ... }`              | `Car myCar = new Car();`                    |

### Приклад:

```java
class Car {
    String color;
    void drive() {
        System.out.println("Авто їде");
    }
}

Car car1 = new Car(); // car1 — об’єкт класу Car
car1.color = "червоний";
car1.drive(); // Виведе: Авто їде
```

- `Car` — клас, який описує, що таке автомобіль.
- `car1` — об’єкт, конкретний автомобіль з кольором та поведінкою.

### Висновок:

- **Клас** — це опис *що таке об'єкт*.
- **Об’єкт** — це *реалізація* цього опису під час виконання.
- Один клас може використовуватись для створення **багатьох об’єктів**.
- Без класів немає об’єктів, але без об’єктів класи не мають практичного сенсу.

> Клас — це те, що ми проектуємо. Об’єкт — це те, з чим ми працюємо.

---

## Що таке інтерфейс і як він використовується в ООП?

**Інтерфейс** в об’єктно-орієнтованому програмуванні — це **контракт**, який визначає **набір методів**, що мають бути реалізовані класами, які цей інтерфейс імплементують. Він описує **"що саме має бути зроблено"**, але не **"як саме це зробити"**.

### Основні властивості інтерфейсу:

- **Не містить реалізації** методів (до Java 8) або містить лише **дефолтну/статичну реалізацію** (починаючи з Java 8).
- Може містити **константи** (поля `public static final`).
- Клас, який реалізує інтерфейс, **зобов’язаний реалізувати всі його методи**.

> Інтерфейс — це чиста абстракція. Він не знає нічого про реалізацію, лише вимагає дотримання форми.

### Навіщо потрібні інтерфейси:

- Для **створення єдиної точки взаємодії** з об’єктами різних типів.
- Для **реалізації поліморфізму**.
- Для **розділення обов’язків** і **гнучкої архітектури**.
- Для **тестування**, де можна легко підмінити реалізацію (наприклад, на мок).

### Приклад на Java:

```java
// Оголошення інтерфейсу
public interface Animal {
    void makeSound();
}
```

```java
// Клас, який реалізує інтерфейс
public class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Гав-гав");
    }
}

public class Cat implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Няв");
    }
}
```

```java
// Використання
public class Zoo {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();

        dog.makeSound(); // Виведе: Гав-гав
        cat.makeSound(); // Виведе: Няв
    }
}
```

### Пояснення:

- `Animal` — інтерфейс, який гарантує, що всі тварини можуть видавати звук.
- `Dog` і `Cat` реалізують `makeSound()` по-своєму.
- Об'єкти різних класів можуть використовуватись через **одну й ту саму змінну типу `Animal`**.

### Висновок:

- **Інтерфейс** — це спосіб **описати поведінку**, яку мають реалізовувати різні класи.
- Він дозволяє **відокремити реалізацію від визначення**, створюючи **гнучку, масштабовану та поліморфну архітектуру**.
- У Java, один клас може **реалізовувати багато інтерфейсів**, що дає змогу уникати обмежень одиничного наслідування.

> Інтерфейси — ключовий інструмент створення гнучкого та модульного коду в ООП.

---

## Що означає реалізує інтерфейс (implements interface)?

У мовах об’єктно-орієнтованого програмування, таких як Java, коли клас **реалізує інтерфейс** (ключове слово `implements`), це означає, що **клас зобов’язується надати конкретну реалізацію всіх методів, оголошених в інтерфейсі**.

> Інтерфейс визначає **"що потрібно зробити"**, а клас реалізує **"як саме це буде зроблено"**.

### Синтаксис Java:

```java
public interface Vehicle {
    void drive();
}
```

```java
public class Car implements Vehicle {
    @Override
    public void drive() {
        System.out.println("Автомобіль їде");
    }
}
```

- `Vehicle` — це інтерфейс.
- `Car` — клас, який **реалізує** інтерфейс `Vehicle`.
- Ключове слово `implements` вказує, що `Car` **виконує контракт**, заданий інтерфейсом `Vehicle`.
- Клас `Car` зобов'язаний реалізувати метод `drive()`.

### Ключові особливості:

- Один клас може **реалізовувати кілька інтерфейсів**, розділених комами:

```java
public class Smartphone implements Camera, GPS, Phone { ... }
```

- Це дозволяє **досягати множинної поведінки** (на відміну від класичного успадкування, яке обмежене одним батьківським класом).

### Навіщо реалізовувати інтерфейси?

- Щоб **забезпечити спільний інтерфейс** для різних класів.
- Для реалізації **поліморфізму**: об'єкти різних класів можна використовувати однаково.
- Для **розділення логіки** та **спрощення тестування** (наприклад, легко підмінити реалізацію на мок).
- Для **гнучкої архітектури**: можна змінити реалізацію без зміни контракту.

### Висновок:

Коли клас **реалізує інтерфейс**, він:
- **дотримується контракту**, визначеного інтерфейсом,
- **гарантує наявність методів**, потрібних для взаємодії,
- забезпечує **гнучку, масштабовану структуру програми**.

> Реалізація інтерфейсу — це спосіб "пообіцяти", що клас підтримує певну поведінку, і дотримати цієї обіцянки за допомогою власної реалізації.

---

## Що означає успадковує клас (extends class)?

Коли один клас **успадковує інший клас** (використовуючи ключове слово `extends`), це означає, що **новий клас (нащадок) автоматично отримує всі публічні та захищені (protected) поля й методи батьківського класу**, а також може **розширювати або змінювати їхню поведінку**.

> Іншими словами, клас-нащадок **переймає функціональність батьківського класу**, з можливістю її змінити чи доповнити.

### Основи синтаксису (Java):

```java
public class Animal {
    public void makeSound() {
        System.out.println("Some generic sound");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof");
    }
}
```

- `Dog` **успадковує** клас `Animal` через `extends`.
- Метод `makeSound()` у `Dog` **перевизначає** метод з базового класу.

### Ключові особливості:

- Клас-нащадок має доступ до всіх **публічних і захищених** методів/полів батьківського класу.
- Може додавати **власні методи й поля**.
- Може **перевизначати методи** (override) з батьківського класу.
- **Не успадковуються приватні (`private`) елементи** базового класу.
- Java підтримує **тільки одиничне успадкування** між класами (один батьківський клас).

### Приклад:

```java
class Vehicle {
    public void drive() {
        System.out.println("Рухається транспорт");
    }
}

class Car extends Vehicle {
    @Override
    public void drive() {
        System.out.println("Автомобіль їде");
    }
}
```

```java
Vehicle v = new Car();
v.drive(); // Виведе: Автомобіль їде
```

### Висновок:

- Ключове слово `extends` вказує, що **клас-нащадок базується на існуючому класі**.
- Це основа **наслідування в ООП**, що дозволяє:
   - **повторно використовувати код**,
   - **організовувати ієрархію класів**,
   - реалізовувати **поліморфізм**.
- Наслідування дає змогу створювати **спеціалізовані класи** на основі більш загальних.

> `extends` — це міст між базовим функціоналом і його розширеною версією.

---

## Що таке конструктор? Які бувають типи конструкторів?

**Конструктор** — це спеціальний метод класу, який викликається автоматично при створенні нового об’єкта. Його основна мета — **ініціалізувати об’єкт**, тобто надати початкові значення змінним екземпляра або виконати необхідні дії під час створення.

Конструктор має такі характеристики:
- Назва конструктора **збігається з назвою класу**.
- Не має **повертаного типу** (навіть `void`).
- Може бути перевантаженим (тобто в класі може бути кілька конструкторів з різними параметрами).

### Типи конструкторів

#### За замовчуванням (default constructor)

Це конструктор без параметрів, який створюється автоматично компілятором, якщо не вказано жодного явного конструктора.

```java
class Person {
    String name;
}
Person p = new Person(); // Виклик конструктора за замовчуванням
```

#### Явно визначений (explicit constructor)

Це конструктор, створений програмістом, з параметрами або без. Якщо хоча б один явний конструктор задано, конструктор за замовчуванням вже не створюється автоматично.

```java
class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }
}
Person p = new Person("Олена");
```

#### Перевантажений (overloaded constructor)

Це кілька конструкторів в одному класі з різними списками параметрів. Дозволяє створювати об’єкти з різними варіантами ініціалізації.

```java
class Rectangle {
    int width, height;

    public Rectangle() {
        this.width = 1;
        this.height = 1;
    }

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```

#### Приватний конструктор

Використовується, коли потрібно обмежити створення об’єктів (наприклад, у шаблоні Singleton).

```java
class Singleton {
    private static Singleton instance;
    private Singleton() {} // приватний конструктор

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### Висновок

Конструктори є важливою частиною класів в ООП. Вони дозволяють забезпечити правильну ініціалізацію об’єктів і надати гнучкість у створенні екземплярів з різними параметрами. Розумне використання конструкторів підвищує надійність і зрозумілість коду.

---








## У чому полягають переваги та недоліки ООП?

---

## Яка роль модифікаторів доступу (private, protected, public) у реалізації інкапсуляції?

---

## У чому різниця між перевантаженням (overloading) та перевизначенням (overriding) методів?

---

## Що таке dynamic dispatch (динамічна диспетчеризація)?

---

## У чому різниця між абстрактним класом та інтерфейсом?

---

## Чим відрізняється компіляторне (статичне) та виконуване (динамічне) зв’язування?

---

## Що таке final метод / клас / змінна і як це пов’язано з ООП?

---

## Яка роль ключового слова super?

---

## Як працює механізм пізнього (динамічного) зв'язування в Java?

---

## Що таке instanceof і як воно пов'язане з поліморфізмом?

---

## Чим відрізняється shallow copy від deep copy?

---








## Що означають принципи «IS-A» (є) та «HAS-A» (має)?

---

## У чому різниця між композицією та агрегацією?

---

## Чому композиція вважається кращою за успадкування?

---

## Що таке «Liskov Substitution Principle» (Принцип підстановки Лісков)?

---

## Як реалізується інтерфейсний поліморфізм у Java?

---

## Що таке шаблонний метод (template method pattern) і як він пов’язаний з ООП?

---

## Як реалізується інкапсуляція на рівні модуля або пакету?

---

## Як працює механізм віртуальних методів (virtual methods)?

---

## Які типові помилки при використанні ООП?

---

## Що таке множинне наслідування? Чому Java його не підтримує для класів?

---

## Як Java дозволяє реалізувати подібність до множинного наслідування?

---








## У яких випадках краще використовувати абстрактний клас, а в яких — інтерфейс?

---

## Опишіть приклад, де доцільно застосувати композицію замість успадкування.

---

## Як за допомогою ООП реалізувати систему розрахунку заробітної плати для працівників різних типів?

---

## Чи можна реалізувати інкапсуляцію без використання модифікаторів доступу?

---

## Як виглядає UML-діаграма класів для прикладу з успадкуванням і композицією?

---

## Чи є можливість створити повністю незмінний об'єкт (Immutable)? Як це вписується в ООП?

---
